

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>14 Scheduling Packets &mdash; zzq&#39;s blog</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
  

  
        <link rel="index" title="索引"
              href="../genindex.html"/>
        <link rel="search" title="搜索" href="../search.html"/>
    <link rel="top" title="zzq&#39;s blog" href="../index.html"/>
        <link rel="up" title="网络算法学" href="index.html"/>
        <link rel="next" title="wireshark" href="../wireshark/index.html"/>
        <link rel="prev" title="9 Protocol Processing" href="proto_process.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> 赵子清技术文章
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../dpdk/index.html">DPDK</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/eal.html">1. EAL</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/eal.html#linuxeal">1.1. Linux环境的EAL</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/eal.html#id1">1.2. 内存机制与初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/eal.html#cpu">1.3. CPU信息取得与核绑定</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/eal.html#lcore">1.4. 线程/lcore的初始化与启动</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/eal.html#id2">1.5. 多进程应用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/eal.html#id3">1.6. 其他注意事项</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/eal.html#id4">1.7. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/ring.html">2. Ring</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/ring.html#id1">2.1. 概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/ring.html#id4">2.2. 应用场景</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/ring.html#id5">2.3. 无锁队列操作图解</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/ring.html#step1">2.3.1. Step1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/ring.html#step2">2.3.2. Step2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/ring.html#step3">2.3.3. Step3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/ring.html#step4">2.3.4. Step4</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/ring.html#step5">2.3.5. Step5</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/ring.html#id6">2.4. 数据结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/ring.html#id7">2.5. 多生产者入队</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/ring.html#id8">2.6. 多消费者出队</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/ring.html#id9">2.7. 索引计算</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/ring.html#id10">2.8. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/mem.html">3. Memory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mem.html#id1">3.1. 内存的初始化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/mem.html#id2">3.1.1. 大页信息初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/mem.html#id3">3.1.2. 大页内存初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/mem.html#memzone">3.1.3. memzone初始化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mem.html#id6">3.2. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/memseg.html">4. Memseg</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/memseg.html#id1">4.1. 概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/memseg.html#id2">4.2. 数据结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/memseg.html#id3">4.3. 初始化</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/memzone.html">5. Memzone</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/memzone.html#id1">5.1. 概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/memzone.html#memzone-init">5.2. 初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/memzone.html#id3">5.3. 内存分配</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/memzone.html#id4">5.4. 内存释放</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/memzone.html#id5">5.5. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/malloc.html">6. Malloc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/malloc.html#id1">6.1. 概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/malloc.html#id2">6.2. 数据结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/malloc.html#malloc-heap">6.3. malloc heap初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/malloc.html#malloc-heap-alloc">6.4. 内存分配</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/malloc.html#id4">6.5. 内存释放</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/malloc.html#id5">6.6. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/mempool.html">7. Mempool</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mempool.html#id1">7.1. 概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mempool.html#id2">7.2. 特性</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/mempool.html#id3">7.2.1. 内存对齐</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/mempool.html#cache">7.2.2. Cache机制</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mempool.html#id4">7.3. 数据结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mempool.html#id5">7.4. 创建</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mempool.html#id6">7.5. 取出对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mempool.html#id7">7.6. 还回对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mempool.html#id8">7.7. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/mbuf.html">8. Mbuf</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mbuf.html#id1">8.1. 概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mbuf.html#id2">8.2. 原理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mbuf.html#id3">8.3. 数据结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mbuf.html#id4">8.4. 分配与回收</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/mbuf.html#id5">8.4.1. 初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/mbuf.html#id6">8.4.2. 分配</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/mbuf.html#id7">8.4.3. 回收</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mbuf.html#id8">8.5. 元信息</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mbuf.html#directindirect-mbuf">8.6. Direct和Indirect mbuf</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/mbuf.html#id9">8.7. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/build_sys.html">9. 编译系统</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/build_sys.html#id2">9.1. 概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/build_sys.html#id3">9.2. 源码组织</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#config">9.2.1. config</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#mk">9.2.2. mk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#drivers">9.2.3. drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#lib">9.2.4. lib</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#tools">9.2.5. tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#app">9.2.6. app</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#examples">9.2.7. examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/build_sys.html#id5">9.3. 编译系统</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#dpdk">9.3.1. 编译dpdk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#id6">9.3.2. 编译外部程序</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/build_sys.html#dpdk-makefile">9.4. dpdk Makefile介绍</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#id7">9.4.1. 一般规则</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#id8">9.4.2. 类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#id13">9.4.3. 常用变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#makefile">9.4.4. 仅可以在Makefile中设置的变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#id14">9.4.5. 仅可以在命令行中设置的变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#id15">9.4.6. 可以在Makefile或命令行中设置的变量</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/build_sys.html#root-makefile-help">9.5. 根Makefile介绍</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#config-target">9.5.1. config target</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#build-target">9.5.2. build target</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#install-target">9.5.3. install target</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#test-target">9.5.4. test target</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#target">9.5.5. 文档target</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#deps-target">9.5.6. deps target</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#id17">9.5.7. 杂项target</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#id18">9.5.8. 其他命令行变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#debug">9.5.9. 编译Debug版本</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/build_sys.html#abi">9.6. ABI管理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#id19">9.6.1. 什么是ABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#dpdk-abi">9.6.2. DPDK ABI策略</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#id20">9.6.3. ABI宏及示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#id21">9.6.4. 验证ABI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/build_sys.html#v16-07-2">9.7. 实例：将v16.07.2编译为单个动态库</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#config-common-base">9.7.1. config/common_base</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#mk-rte-lib-mk">9.7.2. mk/rte.lib.mk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#mk-rte-combinedlib-mk">9.7.3. mk/rte.combinedlib.mk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#mk-rte-app-mk">9.7.4. mk/rte.app.mk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/build_sys.html#libdpdk-map">9.7.5. libdpdk.map</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/build_sys.html#id22">9.8. 参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dpdk/optimization.html">10. dpdk软件性能优化技术</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/optimization.html#id1">10.1. 概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dpdk/optimization.html#cache">10.2. Cache和内存</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../dpdk/optimization.html#id2">10.2.1. 内存Cache简介</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tcpip/index.html">TCP/IP详解</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">网络算法学</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="proto_process.html">9 Protocol Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proto_process.html#id1">9.1 缓存管理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proto_process.html#id2">9.1.1 缓存分配</a></li>
<li class="toctree-l4"><a class="reference internal" href="proto_process.html#id3">9.1.2 缓存的共享</a></li>
<li class="toctree-l4"><a class="reference internal" href="proto_process.html#dpdk">9.1.3 dpdk内存实现</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proto_process.html#crcchecksum">9.2 CRC和Checksum</a></li>
<li class="toctree-l3"><a class="reference internal" href="proto_process.html#id4">9.3 通用协议处理</a></li>
<li class="toctree-l3"><a class="reference internal" href="proto_process.html#id5">9.4 重组</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proto_process.html#id6">9.4.1 高效重组</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proto_process.html#id7">9.5 结论</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">14 Scheduling Packets</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">14.1 概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">14.2 拥塞控制</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">14.2.1 设计目标</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">14.2.2 算法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wred">14.2.3 WRED</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dpdk-red">14.2.4 dpdk red的相关实现</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id13">14.3 带宽与突发限制</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id16">14.3.1 基本原理</a></li>
<li class="toctree-l4"><a class="reference internal" href="#srtcm">14.3.2 srTCM</a></li>
<li class="toctree-l4"><a class="reference internal" href="#trtcm">14.3.3 trTCM</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dpdk-meter">14.3.4 dpdk_meter的相关实现</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id24">14.4 多队列与优先级</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id25">14.5 资源预留协议</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id26">14.6 带宽保证</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id27">14.6.1 问题引入</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deficit-round-robin">14.6.1 Deficit Round-Robin</a></li>
<li class="toctree-l4"><a class="reference internal" href="#drr">14.6.2 DRR的实现与扩展</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id30">14.7 时延保证</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scalable-fair-queuing">14.8 Scalable Fair Queuing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dpdk">14.9 dpdk分层调度</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id31">14.9.1 概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id32">14.9.2 调度分层</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id33">14.9.3 实现</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#diffserv">14.10 DiffServ架构介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dpdk-qos">14.11 dpdk QoS框架</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id37">附录</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ewma">EWMA</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id38">参考</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../wireshark/index.html">wireshark</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../algo/index.html">算法与问题</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../algo/ac.html">AC算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algo/regex.html">正则表达式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../algo/regex.html#id2">1. 概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../algo/regex.html#parse">2. 解析(parse)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../algo/regex.html#id4">2.1 词法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../algo/regex.html#id5">2.2 语法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../algo/regex.html#id6">2.3 抽象语法树</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../algo/regex.html#compile">3. 编译(compile)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../algo/regex.html#nfa">3.1 构造NFA</a></li>
<li class="toctree-l4"><a class="reference internal" href="../algo/regex.html#nfadfa">3.2 NFA转DFA</a></li>
<li class="toctree-l4"><a class="reference internal" href="../algo/regex.html#id8">3.4 消除死状态</a></li>
<li class="toctree-l4"><a class="reference internal" href="../algo/regex.html#dfa">3.5 DFA最小化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../algo/regex.html#id9">3.6 DFA序列化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../algo/regex.html#match">4. 匹配(match)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../algo/regex.html#id10">5. 优化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../algo/regex.html#id11">5.1 内存</a></li>
<li class="toctree-l4"><a class="reference internal" href="../algo/regex.html#id12">5.2 性能</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../algo/regex.html#id13">参考</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../perf/index.html">性能优化</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../perf/vtune.html">Intel VTune Amplifier</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../perf/vtune.html#id1">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../perf/vtune.html#id2">一般应用: 图形界面</a></li>
<li class="toctree-l3"><a class="reference internal" href="../perf/vtune.html#id3">一般应用: 命令行</a></li>
<li class="toctree-l3"><a class="reference internal" href="../perf/vtune.html#vtune">附录: VTune中文在线课程</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../asm/index.html">汇编语言</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../asm/pcasm.html">PC Assembly Language读书笔记</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../lua/index.html">Lua语言</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../lua/basic.html">语言基础</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../lua/basic.html#id2">预备知识</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#lua">获得lua</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#id3">lua命令行</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#id4">保留关键字</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#id5">注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#chunk">Chunk</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../lua/basic.html#id6">数据类型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#string">string</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#userdata">userdata</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#thread">thread</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../lua/basic.html#id7">表达式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#id8">算术运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#id9">关系运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#id10">逻辑运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#id11">连接运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#id12">运算符优先级</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../lua/basic.html#id13">语句</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#id14">赋值</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#id15">局部变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#id16">条件语句</a></li>
<li class="toctree-l4"><a class="reference internal" href="../lua/basic.html#id17">循环语句</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../lua/basic.html#id18">函数</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">工具与杂项</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tools/vim/index.html">Vim</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../tools/vim/intro.html">简介与基本配置</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/vim/intro.html#vim">为什么要使用vim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/vim/intro.html#id2">本系列文章的指导思想和一些约定</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/vim/intro.html#id3">学习之前的基本配置和几个需要了解的基本操作</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../tools/git/index.html">Git</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../tools/git/basic_command.html">Git常用命令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/git/basic_command.html#id2">一、新建代码库</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/git/basic_command.html#id3">二、配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/git/basic_command.html#id4">三、增加/删除文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/git/basic_command.html#id5">四、代码提交</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/git/basic_command.html#id6">五、分支</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/git/basic_command.html#id7">六、标签</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/git/basic_command.html#id8">七、查看信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/git/basic_command.html#id9">八、远程同步</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/git/basic_command.html#id10">九、撤销</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/git/basic_command.html#id11">十、其他</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../tools/git/tricks.html">小技巧</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/git/tricks.html#shellsshgithub">shell通过SSH连接github</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/git/tricks.html#id2">在命令提示符中显示当前分支</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../tools/rest/index.html">用reST编写文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../tools/rest/intro.html">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tools/rest/setup.html">安装与基本使用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/setup.html#id2">安装软件包</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/setup.html#id3">项目建立</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/setup.html#conf-py">conf.py配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/setup.html#index">index页配置</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../tools/rest/grammar.html">reST语法介绍</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id1">章节标题</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id2">段落</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id3">行内标记</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id4">列表</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id5">代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id6">超链接</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id7">图片</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id8">表格</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id9">引用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id10">脚注</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id11">提醒</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id12">替换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/grammar.html#id13">参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../tools/rest/style.html">修改样式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/style.html#step1">Step1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/style.html#step2">Step2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/style.html#step3">Step3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../tools/rest/topdf.html">生成PDF</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/topdf.html#xetex">方法一：使用xeTex(推荐)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/topdf.html#cjkutf8">方法二: 使用CJKutf8包 (默认)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/topdf.html#id1">终极解决办法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../tools/rest/doxygen.html">生成API文档</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/doxygen.html#step1">Step1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/doxygen.html#step2">Step2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/doxygen.html#step3">Step3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/doxygen.html#step4">Step4</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../tools/rest/with_vscode.html">在Visual Studio Code中使用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/with_vscode.html#id1">安装步骤</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/with_vscode.html#id2">配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/with_vscode.html#id3">使用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/rest/with_vscode.html#id4">问题记录</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../tools/patch.html">补丁工具patch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../tools/patch.html#id1">1 为单个文件生成补丁</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tools/patch.html#id2">2 为多个文件生成补丁</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tools/patch.html#id3">3 打补丁</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tools/patch.html#id4">4 示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../tools/libpcap.html">libpcap使用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../tools/libpcap.html#id1">创建句柄</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/libpcap.html#pcap-open-offline">pcap_open_offline</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/libpcap.html#pcap-dump-open">pcap_dump_open</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../tools/libpcap.html#id2">关闭句柄</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/libpcap.html#pcap-close">pcap_close</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/libpcap.html#pcap-dump-close">pcap_dump_close</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../tools/libpcap.html#packet">读取packet</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/libpcap.html#pcap-open-pcap-dispatch">pcap_open/pcap_dispatch</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../tools/libpcap.html#id3">设置选项</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/libpcap.html#pcap-set-promisc">pcap_set_promisc</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../tools/libpcap.html#id4">其他</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../tools/libpcap.html#pcap-breakloop">pcap_breakloop</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/libpcap.html#pcap-file">pcap_file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tools/libpcap.html#pcap-dump-file">pcap_dump_file</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../tools/libpcap.html#id5">参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../tools/cunit.html">CUnit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../tools/cunit.html#cunit-2-1-3">编译安装CUnit-2.1-3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../tools/centos.html">CentOS应用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../tools/centos.html#failed-to-start-lsb-bring-up-down-networking">网络配置失败,显示Failed to start LSB: Bring up/down networking</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../hobby/index.html">兴趣爱好</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../hobby/prepare.html">准备工作</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../hobby/prepare.html#b">如何下载B站视频，或者小偶像用微博发的视频？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hobby/prepare.html#mac">Mac系统下应该用什么软件做视频编辑？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hobby/prepare.html#q-mac-gif">Q: Mac系统如何做动图（gif）？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hobby/prepare.html#gif-fcpx">我有一些动图（gif），怎么将它们导入到fcpx？直接导入发现它们不动了啊！</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hobby/prepare.html#id2">Mac系统如何录制系统自己发出的声音，比如我正在听一首很好听的歌但是不方便下载它？</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../hobby/fcpx_basic.html">FCPX: XXX</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../hobby/fcpx_basic.html#library">资源库（Library）</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hobby/fcpx_basic.html#id1">疑难点</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">赵子清技术文章</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">网络算法学</a> &raquo;</li>
        
      <li>14 Scheduling Packets</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="scheduling-packets">
<h1>14 Scheduling Packets<a class="headerlink" href="#scheduling-packets" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>14.1 概述<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>最简单的情况下，网络设备对流量采取的是“尽力而为”的策略。可以想象在Tx处有一个FIFO发送队列，当设备处理不过来时，队列满，后到的报文无法入队，将被丢弃。这种机制可以称为FIFO with tail-drop。</p>
<p>对于一个现代的网络设备来说，仅仅使用上述简单机制是不行的，而是满足以下几个需求：</p>
<ul>
<li><p class="first">拥塞控制</p>
<p>链路的拥塞几乎是不可避免的。TCP协议虽然有拥塞避免机制，但仍需要在设备上实现某种拥塞控制机制，协助TCP的拥塞避免机制更好地工作，充分利用链路带宽。</p>
</li>
<li><p class="first">链路资源均享</p>
<p>传统的FIFO和tail-drop机制，会使流量较大的业务流量“淹没”流量小但却可能比较重要的业务流量，达不到带宽均享的效果。比如大量的文件下载流量可能会占用同一链路上的所有buffer，导致telnet等报文无法正常传输，telnet客户会发现连接无响应。</p>
</li>
<li><p class="first">QoS保证</p>
<p>链路资源均享的更精确形式是提供带宽保证，例如某ISP可能需要为某客户预留10M带宽。更困难的是提供时延保证，例如保证直播视频流有较小的时延。</p>
</li>
</ul>
<p>报文调度就是为了解决以上问题。针对不同的需求，有不同的调度算法或机制。本章对主要的报文调度机制进行了叙述，这些内容有：</p>
<ul class="simple">
<li>拥塞控制</li>
<li>带宽与突发限制</li>
<li>多队列与优先级机制</li>
<li>资源预留协议</li>
<li>带宽保证</li>
<li>时延保证</li>
<li>Scalable Fair Queuing</li>
<li>dpdk分层调度</li>
<li>DiffServ架构介绍</li>
<li>dpdk QoS框架</li>
</ul>
</div>
<div class="section" id="id2">
<h2>14.2 拥塞控制<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>RED(Random Early Detection, 参考 <a class="reference internal" href="#id41" id="id3">[red]</a> )是一种用于拥塞控制的调度机制，它已经成为一个事实上的标准，被广泛应用。</p>
<p>RED通过监视报文队列，动态计算其拥塞程度，并据此以某种规则丢弃队列中的报文(即使此时队列仍有空间)，实现拥塞控制。</p>
<p>相比于简单的Tail Drop，RED可以避免TCP的全局同步(即TCP发现丢了多个包，从而急剧减小window&lt;慢开始&gt;，拥塞解除；
但后来不再拥塞时又开始加快发送速度，又一次造成拥塞...这样的现象周而复始，使得一段时间内设备带宽利用率很低的现象)。</p>
<p>RED只在设备上实现，不需要依赖连接双方。</p>
<div class="section" id="id4">
<h3>14.2.1 设计目标<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
</div>
<div class="section" id="id5">
<h3>14.2.2 算法<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>RED使用低通滤波器来计算平均队列长度(avg)。avg与两个门限值比较,
最小门限min<sub>th</sub>，最大门限max<sub>th</sub>。RED的基本算法是：</p>
<ul class="simple">
<li>当avg小于最小门限时，不mark任何报文</li>
<li>当avg大于最大门限时，mark所有报文</li>
<li>当avg介于最小和最大门限之间时，以概率P<sub>a</sub> mark报文，
此概述是avg的函数。Each time that a packet is marked, the
probability that a packet is marked from a particular connection
is roughly proportional to that connection’s share of the
bandwidth at the gateway</li>
</ul>
<p>以概率随机丢弃报文，使得拥塞控制只在个别连接进行，从而避免全局性的拥塞控制。</p>
<img alt="../_images/red_algo_general.png" src="../_images/red_algo_general.png" />
<p>所以RED算法分为两部分：</p>
<ol class="arabic simple">
<li><strong>计算平均队列长度</strong>  它决定了队列中所允许的突发度</li>
<li><strong>计算报文mark概率</strong>  它决定了在当前拥塞程度下mark报文的频率，
目标是以合适的间隔mark报文，以避免偏见和全局同步，并以足够合适的频率mark报文以控制平均队列长度。</li>
</ol>
<p>RED把设备的报文队列分为3个部分:</p>
<img alt="../_images/red_queue.png" src="../_images/red_queue.png" />
<p>mark概率与两个门限值的关系：</p>
<img alt="../_images/red_param_relation.png" src="../_images/red_param_relation.png" />
<p>瞬时队列长度与平均队列长度的区别：</p>
<img alt="../_images/red_queue_size.png" src="../_images/red_queue_size.png" />
<p>RED详细算法:</p>
<img alt="../_images/red_algo_detail.png" src="../_images/red_algo_detail.png" />
<div class="section" id="id6">
<h4>平均队列长度的计算<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>RED使用低通滤波器计算平均队列长度。这样做的好处是，突发或拥塞造成的队列长度的短时间增加不会导致平均队列长度有太大的增加。</p>
<p>此低通滤波器是一个”指数加权移动平均“(EWMA)：</p>
<blockquote>
<div>avg = (1 - w<sub>q</sub> ) * avg + w<sub>q</sub> * q</div></blockquote>
<p>权重参数w<sub>q</sub>确定了低通滤波器的时间常数。w<sub>q</sub>设置过大时，
会导致瞬时拥塞无法通过滤波器；w<sub>q</sub>设置过小时，会使avg对实际队列长度的变化响应过慢，从而无法探测到拥塞的初始阶段。</p>
<p>两个门限的设置取决于想要的平均队列长度。min<sub>th</sub>与典型流量的突发性有关；max<sub>th</sub>与时延有关。当(max<sub>th</sub> -
min<sub>th</sub>)大于一次RTT内avg的增加值时RED算法最为有效。一个经验法则是把max<sub>th</sub>至少设为min<sub>th</sub>的两倍。</p>
<p>EWMA见 <a class="reference internal" href="#id39" id="id7">[ewma]</a> , 附录 <a class="reference internal" href="#ewma-algo"><span class="std std-ref">EWMA</span></a> 中也有介绍。</p>
</div>
<div class="section" id="id8">
<h4>参数选取原则<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>w<sub>q</sub> &gt;= 0.001</li>
<li>min<sub>th</sub>足够大以充分利用带宽</li>
<li>(max<sub>th</sub> - min<sub>th</sub>)足够大以避免全局同步</li>
</ul>
</div>
<div class="section" id="red">
<h4>优化的RED算法<a class="headerlink" href="#red" title="永久链接至标题">¶</a></h4>
<img alt="../_images/red_algo_opt.png" src="../_images/red_algo_opt.png" />
</div>
</div>
<div class="section" id="wred">
<h3>14.2.3 WRED<a class="headerlink" href="#wred" title="永久链接至标题">¶</a></h3>
<p>// TODO</p>
</div>
<div class="section" id="dpdk-red">
<h3>14.2.4 dpdk red的相关实现<a class="headerlink" href="#dpdk-red" title="永久链接至标题">¶</a></h3>
<p>RED在dpdk中的实现代码在</p>
<ul class="simple">
<li>lib/librte_sched/rte_red.h</li>
<li>lib/librte_sched/rte_red.c</li>
</ul>
<p>RED/WRED是dpdk Dropper的一部分，它与Scheduler的集成关系如下图所示：</p>
<img alt="../_images/red_dpdk.png" src="../_images/red_dpdk.png" />
<p>dpdk Dropper支持3种算法：RED、WRED和Tail Drop。在运行时先使用RED/WRED检测，
再使用Tail Drop检测。</p>
<p>dpdk Dropper的用法如下：</p>
<ol class="arabic simple">
<li>初始化配置数据</li>
<li>初始化运行时数据</li>
<li>入队(Enqueue)，决定将报文入队还是丢弃</li>
<li>mark空队(Mark Empty)，当报文队列为空时记下时间</li>
</ol>
<div class="section" id="id9">
<h4>14.2.4.1 配置<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<p>dpdk RED共有4个配置参数：最小门限、最大门限、mark概率倒数，以及EWMA权重。</p>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="9%" />
<col width="11%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">参数</th>
<th class="head">Min</th>
<th class="head">Max</th>
<th class="head">典型值</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>最小门限 Min<sub>th</sub></td>
<td>0</td>
<td>1022</td>
<td>1/4 队列长度</td>
</tr>
<tr class="row-odd"><td>最大门限 Max<sub>th</sub></td>
<td>1</td>
<td>1023</td>
<td>1/2 队列长度</td>
</tr>
<tr class="row-even"><td>mark概率倒数 1/max<sub>p</sub></td>
<td>1</td>
<td>255</td>
<td>10</td>
</tr>
<tr class="row-odd"><td>EWMA权重 w<sub>q</sub></td>
<td>1</td>
<td>12</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>这里，mark概率是以倒数形式给出的，比如概率是1%=1/100，则这个配置值就是100。EWMA权重是实际权重的倒数的2的对数，比如实际权重是1/2^9，
那么它的倒数是2^9，再取2的对数，即9做为这里的配置值。</p>
</div>
<div class="section" id="enqueue">
<h4>14.2.4.2 Enqueue<a class="headerlink" href="#enqueue" title="永久链接至标题">¶</a></h4>
<p>dpdk Dropper的数据流如下图所示：</p>
<img alt="../_images/red_dpdk_dataflow.png" src="../_images/red_dpdk_dataflow.png" />
<p>其中，q是实际队列长度，avg是计算得到的平均队列长度，count是上次丢弃到现在的报文数，decision是判断结果。其作参数都是配置值。</p>
<p><strong>EWMA模块</strong></p>
<p>这里使用了 <a class="reference internal" href="#id41" id="id10">[red]</a> 提到的优化算法。wq = 1/2^n，n就是上面配置参数中的EWMA权重。</p>
<p>队列为空时，avg不能突然变为0或者继续保持旧值，而是应逐渐衰减为0。
此时需要求m值，m = (time-qtime)/s。上面的算法已经提到过，s是连续两次入队操作之间的典型时间间隔。</p>
<p>时间基准是以字节为单位的，1个字节单位表示网卡发送1个字节所需的时间长度。dpdk Dropper中参数s被定义为一个常数2^22，表示64K个叶子节点(每个节点都是一个报文队列)中的每个节点发送一个64字节报文所需的时间，它表示了最坏的场景。2^22 = 64*1024*64。这个值在rte_red.h中定义为RTE_RED_S宏。</p>
<p>对(1-wq)^m的计算采取了优化算法。已知</p>
<img alt="../_images/red_eq2_expression.png" src="../_images/red_eq2_expression.png" />
<p>经过变换之后，log2(1-wq)通过查表求得，那么再乘以m，并进行移位操作，
即可求得(1-wq)^m。为了避免算法计算溢出，m和查表值限制为16 bit。</p>
<p><strong>Drop模块</strong></p>
<p>Drop模块的功能是：</p>
<ul class="simple">
<li>将平均队列长度与最小、最大门限进行比较</li>
<li>计算报文丢弃概率</li>
<li>随机选择入队或丢弃报文</li>
</ul>
<p>丢弃概率的计算分2个阶段：</p>
<ol class="arabic simple">
<li>Pb 初始丢弃概率</li>
<li>Pa 实际丢弃概率</li>
</ol>
<p>Pa的计算将count参数考虑在内，使得其值随着上次丢弃后到达报文的增加而增加。</p>
<blockquote>
<div>Pa = Pb/(2 - count * Pb)</div></blockquote>
<p>注意这里分母中的常数为2，而 <a class="reference internal" href="#id41" id="id11">[red]</a> 中的常数为1。当此常数为1时将导致更高的丢弃概率，比较见下图：</p>
<img alt="../_images/red_dpdk_pa.png" src="../_images/red_dpdk_pa.png" />
</div>
<div class="section" id="mark-empty">
<h4>14.2.4.3 Mark Empty<a class="headerlink" href="#mark-empty" title="永久链接至标题">¶</a></h4>
<p>必须记录队列为空的时刻，API调用方负责通知Dropper队列为空的事件。</p>
</div>
<div class="section" id="dpdk-time">
<span id="id12"></span><h4>14.2.4.4 时间值的使用<a class="headerlink" href="#dpdk-time" title="永久链接至标题">¶</a></h4>
<p>在Dropper中需要用到时间值，这里的时间值是以字节为单位表示的，即1字节单位表示网卡发送一个字节所需的时间长度。由于Scheduler每次将报文转给NIC Tx的时候都递增其内部时间戳，所以用字节单位来表示是方便的。这样，当1个报文被调度到Tx时，time += (n+h)，n是报文长度，
h是每个报文所需的分帧开销(framing overhead)。</p>
<p>Scheduler的内部时间戳需要与NIC Tx的速率保持一致，以免报文发送速度过快超过线速导致丢包。在每次出队时，Scheduler读取当前时间。CPU时间戳可以通过TSC寄存器或者HPET寄存器取得，然后通过以下公式从CPU时钟数转换为字节数：</p>
<blockquote>
<div>time_bytes = time_cycles / cycles_per_byte</div></blockquote>
<p>这里cycles_per_byte就是传输1个字节所需的cpu cycles。比如，对于频率为2GHz的CPU和10GbE网口：</p>
<blockquote>
<div>cycles_per_byte = 2000000000 / 10000000000 * 8 = 1.6</div></blockquote>
<p>Scheduler维护一个内部NIC时间戳Ts，每当调度一个报文时，Ts加上报文长度和开销；每当出队时，Scheduler检查Ts与当前时间t：</p>
<ol class="arabic simple">
<li>如果Ts &gt;= t，不需要调整Ts，意味着Scheduler可以满足NIC Tx的需求</li>
<li>如果Ts &lt; t，则调整Ts = t，这意味着Scheduler调度报文的速度跟不上NIC Tx的速度，此时带宽将被浪费</li>
</ol>
<p>声明：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* Timing */</span>
<span class="kt">uint64_t</span> <span class="n">time_cpu_cycles</span><span class="p">;</span> <span class="cm">/* Current CPU time measured in CPU cyles */</span>
<span class="kt">uint64_t</span> <span class="n">time_cpu_bytes</span><span class="p">;</span>  <span class="cm">/* Current CPU time measured in bytes */</span>
<span class="kt">uint64_t</span> <span class="n">time</span><span class="p">;</span>            <span class="cm">/* Current NIC TX time measured in bytes */</span>
<span class="kt">double</span> <span class="n">cycles_per_byte</span><span class="p">;</span>   <span class="cm">/* CPU cycles per byte */</span>
</pre></div>
</div>
<p>这里time就是Ts。</p>
<p>配置时初始化：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* Timing */</span>
<span class="n">port</span><span class="o">-&gt;</span><span class="n">time_cpu_cycles</span> <span class="o">=</span> <span class="n">rte_get_tsc_cycles</span><span class="p">();</span>
<span class="n">port</span><span class="o">-&gt;</span><span class="n">time_cpu_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">port</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">port</span><span class="o">-&gt;</span><span class="n">cycles_per_byte</span> <span class="o">=</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">rte_get_tsc_hz</span><span class="p">())</span> <span class="o">/</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>
</pre></div>
</div>
<p>出队时(rte_sched_port_dequeue)调用rte_sched_port_time_resync：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span>
<span class="nf">rte_sched_port_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_sched_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">**</span><span class="n">pkts</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">n_pkts</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

    <span class="n">port</span><span class="o">-&gt;</span><span class="n">pkts_out</span> <span class="o">=</span> <span class="n">pkts</span><span class="p">;</span>
    <span class="n">port</span><span class="o">-&gt;</span><span class="n">n_pkts_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">rte_sched_port_time_resync</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

    <span class="cm">/* Take each queue in the grinder one step further */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">grinder_handle</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RTE_SCHED_PORT_N_GRINDERS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">==</span> <span class="n">n_pkts</span><span class="p">)</span> <span class="o">||</span>
            <span class="n">rte_sched_port_exceptions</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">RTE_SCHED_PORT_N_GRINDERS</span><span class="p">))</span>
        <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">rte_sched_port_time_resync</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_sched_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">cycles</span> <span class="o">=</span> <span class="n">rte_get_tsc_cycles</span><span class="p">();</span>
    <span class="kt">uint64_t</span> <span class="n">cycles_diff</span> <span class="o">=</span> <span class="n">cycles</span> <span class="o">-</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">time_cpu_cycles</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">bytes_diff</span> <span class="o">=</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">cycles_diff</span><span class="p">)</span> <span class="o">/</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">cycles_per_byte</span><span class="p">;</span>

    <span class="cm">/* Advance port time */</span>
    <span class="n">port</span><span class="o">-&gt;</span><span class="n">time_cpu_cycles</span> <span class="o">=</span> <span class="n">cycles</span><span class="p">;</span>
    <span class="n">port</span><span class="o">-&gt;</span><span class="n">time_cpu_bytes</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">bytes_diff</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">time_cpu_bytes</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">port</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">time_cpu_bytes</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Reset pipe loop detection */</span>
    <span class="n">port</span><span class="o">-&gt;</span><span class="n">pipe_loop</span> <span class="o">=</span> <span class="n">RTE_SCHED_PIPE_INVALID</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在grinder_handle中，会调用grinder_schedule，在其中，调用了</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* Advance port time */</span>
<span class="n">port</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">+=</span> <span class="n">pkt_len</span><span class="p">;</span>
</pre></div>
</div>
<p>即每次调度报文时都更新了时间。</p>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>14.3 带宽与突发限制<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<p>有时需要在网络设备上实现对某些流量的限速，或者对没有拥塞控制机制的UDP流量进行拥塞控制，此时可以使用一种叫做”令牌桶“的算法。这种算法对于每个要控制的流，只需要一个报文队列和一个计数器(shaping时需要队列缓存暂时不能发送的报文，policing时不能发送直接丢弃，不需要队列)。</p>
<p>令牌桶shaping通过控制报文流的平均速率和最大突发大小，来限制其突发性(burstiness)。例如，可以控制某报文流以100Kbps的平均速率长时间地发送报文，但也允许其尽可能快地发送4KB的突发数据。</p>
<p><a class="reference internal" href="#rfc2697" id="id14">[rfc2697]</a> 和 <a class="reference internal" href="#rfc2698" id="id15">[rfc2698]</a> 描述了两种可用于DiffServ的令牌桶算法。</p>
<div class="section" id="id16">
<h3>14.3.1 基本原理<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>令牌桶算法的示意图如下所示：</p>
<img alt="../_images/token_bucket.png" src="../_images/token_bucket.png" />
<p>如图所示，对于要控制的报文流，有一个令牌桶，此桶的大小为B，并以速率R向其中添加令牌(token)。令牌的单位可以为字节。</p>
<p>当报文从Input端到来时，如果报文大小不大于令牌数(以字节计算)，则允许发送；否则，放入队列等待(shaping)更多的令牌，或者直接丢弃(policing)。当报文发送后，需要将令牌数减去报文长度。</p>
</div>
<div class="section" id="srtcm">
<h3>14.3.2 srTCM<a class="headerlink" href="#srtcm" title="永久链接至标题">¶</a></h3>
<div class="section" id="id17">
<h4>介绍<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h4>
<p>srTCM(Single Rate Three Color Marker, 参考 <a class="reference internal" href="#rfc2697" id="id18">[rfc2697]</a> )根据3个流量参数把报文标记为GREEN, YELLOW和RED，这3个标记分别是CIR(Committed Information Rate)，CBS(Committed Burst Size)和EBS(Excess Burst Size)。 标记的规则是：</p>
<ul class="simple">
<li>如果不大于CBS，则标记为GREEN</li>
<li>如果大于CBS但不大于EBS，则标记为YELLOW</li>
<li>其他情况，标记为RED</li>
</ul>
<p>srTCM用于在长度维度(而不是突发速率)上实施策略。</p>
</div>
<div class="section" id="id19">
<h4>配置<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h4>
<p>srTCM的配置项包括模式和3个流量参数。</p>
<p>srTCM有两种模式：</p>
<ul class="simple">
<li>Color-Blind mode, 之前没有其他实体对报文进行染色</li>
<li>Color-Aware mode, 之前已经有其他实体对报文染过色了</li>
</ul>
<p>CIR应配置为每秒IP报文的大小，它包含IP首部，但不包括链路层首部；
CBS和EBS应至少有一个值大于0，当它们大于0时，推荐配置为大于等于流内最大IP报文的大小。</p>
</div>
<div class="section" id="metering">
<h4>Metering<a class="headerlink" href="#metering" title="永久链接至标题">¶</a></h4>
<p>Meter的行为由模式和2个令牌桶C(CBS)、E(EBS)决定。C桶和E桶的速度相同，都是CIR。C的大小为CBS，E的大小是EBS。</p>
<p>设Tc、Te分别为C桶和E桶的令牌计数器，在0时刻，Tc(0)=CBS，Te(0)=EBS，
之后每秒钟按以下规则更新Tc和Te</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">Tc</span> <span class="o">&lt;</span> <span class="n">CBS</span><span class="p">)</span>
    <span class="n">Tc</span> <span class="o">++</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">Te</span> <span class="o">&lt;</span> <span class="n">EBS</span><span class="p">)</span>
    <span class="n">Te</span> <span class="o">++</span><span class="p">;</span>
<span class="k">else</span>
    <span class="k">continue</span><span class="p">;</span>
</pre></div>
</div>
<p>当在时刻t有一个长度为B的报文到来时，在Color-Blind模式时</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">Tc</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">B</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
   <span class="n">Tc</span> <span class="o">-=</span> <span class="n">B</span><span class="p">;</span>
   <span class="n">color</span> <span class="o">=</span> <span class="n">GREEN</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">Te</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">B</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
   <span class="n">Te</span> <span class="o">-=</span> <span class="n">B</span><span class="p">;</span>
   <span class="n">color</span> <span class="o">=</span> <span class="n">YELLOW</span><span class="p">;</span>
<span class="k">else</span>
   <span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
</pre></div>
</div>
<p>在Color-Aware模式时</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">color</span> <span class="o">==</span> <span class="n">GREEN</span> <span class="o">&amp;&amp;</span> <span class="n">Tc</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="n">B</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">GREEN</span><span class="p">;</span>
    <span class="n">Tc</span> <span class="o">-=</span> <span class="n">B</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="n">color</span> <span class="o">==</span> <span class="n">GREEN</span> <span class="o">||</span> <span class="n">color</span> <span class="o">==</span> <span class="n">YELLOW</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">Te</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="n">B</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">YELLOW</span><span class="p">;</span>
    <span class="n">Te</span> <span class="o">-=</span> <span class="n">B</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="marking">
<h4>Marking<a class="headerlink" href="#marking" title="永久链接至标题">¶</a></h4>
<p>//TODO</p>
</div>
</div>
<div class="section" id="trtcm">
<h3>14.3.3 trTCM<a class="headerlink" href="#trtcm" title="永久链接至标题">¶</a></h3>
<div class="section" id="id20">
<h4>介绍<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h4>
<p>trTCM(Two Rate Three Color Marker，参考 <a class="reference internal" href="#rfc2698" id="id21">[rfc2698]</a> )根据2个流量速率参数及其相关的突发大小将报文标记为GREE, YELLOW和RED，
这2个流量速率参数分别是PIR(Peak Information Rate)和CIR(Committed Information Rate)。标记的规则是：</p>
<ul class="simple">
<li>如果大于PIR，标记为RED, 否则</li>
<li>如果大于CIR，标记为YELLOW，否则</li>
<li>如果不大于CIR，标记为GREEN</li>
</ul>
<p>trTCM用于在突发速率维度上实施策略。</p>
</div>
<div class="section" id="id22">
<h4>配置<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h4>
<p>trTCM算法需要配置5个参数：</p>
<ol class="arabic simple">
<li>模式</li>
<li>PIR 及其相关的 PBS(Peak Burst Size)</li>
<li>CIR 及其相关的 CBS(Committed Burst Size)</li>
</ol>
<p>srTCM有两种模式：</p>
<ul class="simple">
<li>Color-Blind mode</li>
<li>Color-Aware mode</li>
</ul>
<p>PIR和CIR是每秒IP报文的大小(字节数)，包括IP首部但不包含链路层首部。PIR不得小于CIR。</p>
<p>PBS和CBS也是字数数大小，两者均大于0。建议设为流内最大IP包的长度。</p>
</div>
<div class="section" id="id23">
<h4>Metering<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h4>
<p>Meter的行为由模式和两个令牌桶P(PBS)、C(CBS)决定。P桶的大小为PBS，速率为PIR；C桶的大小为CBS，速度为CIR。</p>
<p>设Tp、Tc分别为P桶和C桶的令牌计数器，在0时刻，Tp(0)=PBS，Tc(0)=CBS，
之后每一秒钟，Tp += PIR, Tc += CIR。</p>
<p>当在时刻t有一个长度为B的报文到来时，在Color-Blind模式</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">Tp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">B</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">Tc</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">B</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">YELLOW</span><span class="p">;</span>
    <span class="n">Tp</span> <span class="o">-=</span> <span class="n">B</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">GREEN</span><span class="p">;</span>
    <span class="n">Tp</span> <span class="o">-=</span> <span class="n">B</span><span class="p">;</span>
    <span class="n">Tc</span> <span class="o">-=</span> <span class="n">B</span><span class="p">;</span>
</pre></div>
</div>
<p>在Color-Aware模式时</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">color</span> <span class="o">==</span> <span class="n">RED</span> <span class="o">||</span> <span class="n">Tp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="n">B</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">color</span> <span class="o">==</span> <span class="n">YELLOW</span> <span class="o">||</span> <span class="n">Tc</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="n">B</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">YELLOW</span><span class="p">;</span>
    <span class="n">Tp</span> <span class="o">-=</span> <span class="n">B</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">GREEN</span><span class="p">;</span>
    <span class="n">Tp</span> <span class="o">-=</span> <span class="n">B</span><span class="p">;</span>
    <span class="n">Tc</span> <span class="o">-=</span> <span class="n">B</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dpdk-meter">
<h3>14.3.4 dpdk_meter的相关实现<a class="headerlink" href="#dpdk-meter" title="永久链接至标题">¶</a></h3>
<p>dpdk实现了srTCM和trTCM, 代码在&lt;dpdk&gt;/lib/librte_meter. 文档见
<a class="reference external" href="http://dpdk.org/doc/guides/prog_guide/qos_framework.html#traffic-metering">http://dpdk.org/doc/guides/prog_guide/qos_framework.html#traffic-metering</a>.</p>
<p>这里只分析其中的srTCM的Color-Blind模式实现部分.</p>
<p>dpdk meter库为每条流(flow)配置一个meter运行时上下文, 配置结构为:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">rte_meter_srtcm_params</span> <span class="p">{</span>
    <span class="n">uint64_t</span> <span class="n">cir</span><span class="p">;</span> <span class="o">/**&lt;</span> <span class="n">Committed</span> <span class="n">Information</span> <span class="n">Rate</span> <span class="p">(</span><span class="n">CIR</span><span class="p">)</span><span class="o">.</span> <span class="n">Measured</span> <span class="ow">in</span> <span class="nb">bytes</span> <span class="n">per</span> <span class="n">second</span><span class="o">.</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">cbs</span><span class="p">;</span> <span class="o">/**&lt;</span> <span class="n">Committed</span> <span class="n">Burst</span> <span class="n">Size</span> <span class="p">(</span><span class="n">CBS</span><span class="p">)</span><span class="o">.</span>  <span class="n">Measured</span> <span class="ow">in</span> <span class="nb">bytes</span><span class="o">.</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ebs</span><span class="p">;</span> <span class="o">/**&lt;</span> <span class="n">Excess</span> <span class="n">Burst</span> <span class="n">Size</span> <span class="p">(</span><span class="n">EBS</span><span class="p">)</span><span class="o">.</span>  <span class="n">Measured</span> <span class="ow">in</span> <span class="nb">bytes</span><span class="o">.</span> <span class="o">*/</span>
<span class="p">};</span>
</pre></div>
</div>
<p>meter运行时上下文:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">rte_meter_srtcm</span> <span class="p">{</span>
    <span class="n">uint64_t</span> <span class="n">time</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Time</span> <span class="n">of</span> <span class="n">latest</span> <span class="n">update</span> <span class="n">of</span> <span class="n">C</span> <span class="ow">and</span> <span class="n">E</span> <span class="n">token</span> <span class="n">buckets</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">tc</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">Number</span> <span class="n">of</span> <span class="nb">bytes</span> <span class="n">currently</span> <span class="n">available</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">committed</span> <span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="n">token</span> <span class="n">bucket</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">te</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">Number</span> <span class="n">of</span> <span class="nb">bytes</span> <span class="n">currently</span> <span class="n">available</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">excess</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="n">token</span> <span class="n">bucket</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">cbs</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">Upper</span> <span class="n">limit</span> <span class="k">for</span> <span class="n">C</span> <span class="n">token</span> <span class="n">bucket</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">ebs</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">Upper</span> <span class="n">limit</span> <span class="k">for</span> <span class="n">E</span> <span class="n">token</span> <span class="n">bucket</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">cir_period</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">CPU</span> <span class="n">cycles</span> <span class="k">for</span> <span class="n">one</span> <span class="n">update</span> <span class="n">of</span> <span class="n">C</span> <span class="ow">and</span> <span class="n">E</span> <span class="n">token</span> <span class="n">buckets</span> <span class="o">*/</span>
    <span class="n">uint64_t</span> <span class="n">cir_bytes_per_period</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Number</span> <span class="n">of</span> <span class="nb">bytes</span> <span class="n">to</span> <span class="n">add</span> <span class="n">to</span> <span class="n">C</span> <span class="ow">and</span> <span class="n">E</span> <span class="n">token</span> <span class="n">buckets</span> <span class="n">on</span> <span class="n">each</span> <span class="n">update</span> <span class="o">*/</span>
<span class="p">};</span>
</pre></div>
</div>
<p>这里值得注意的是time, cir_period和cir_bytes_per_period这3个成员. 其中, time是上一次桶更新的时间, cir_period是在指定限速速率下两次桶更新之间的CPU cycle数, cir_bytes_per_period是每个cir_peroid桶应添加的令牌数(单位是字节).</p>
<p>根据meter参数配置运行时上下文:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#ifndef RTE_METER_TB_PERIOD_MIN</span>
<span class="cp">#define RTE_METER_TB_PERIOD_MIN      100</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rte_meter_get_tb_params</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">hz</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">rate</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">tb_period</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">tb_bytes_per_period</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">    <span class="kt">double</span> <span class="n">period</span> <span class="o">=</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">hz</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">rate</span><span class="p">);</span>
</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&gt;=</span> <span class="n">RTE_METER_TB_PERIOD_MIN</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">        <span class="o">*</span><span class="n">tb_bytes_per_period</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="hll">        <span class="o">*</span><span class="n">tb_period</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">period</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="hll">        <span class="o">*</span><span class="n">tb_bytes_per_period</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">ceil</span><span class="p">(</span><span class="n">RTE_METER_TB_PERIOD_MIN</span> <span class="o">/</span> <span class="n">period</span><span class="p">);</span>
</span><span class="hll">        <span class="o">*</span><span class="n">tb_period</span> <span class="o">=</span> <span class="p">(</span><span class="n">hz</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">tb_bytes_per_period</span><span class="p">))</span> <span class="o">/</span> <span class="n">rate</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="p">}</span>

<span class="kt">int</span>
<span class="nf">rte_meter_srtcm_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_meter_srtcm</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rte_meter_srtcm_params</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">hz</span><span class="p">;</span>

    <span class="cm">/* Check input parameters */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">params</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">cir</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">cbs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">ebs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Initialize srTCM run-time structure */</span>
    <span class="n">hz</span> <span class="o">=</span> <span class="n">rte_get_tsc_hz</span><span class="p">();</span>
    <span class="n">m</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">rte_get_tsc_cycles</span><span class="p">();</span>
    <span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cbs</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">cbs</span><span class="p">;</span>
    <span class="n">m</span><span class="o">-&gt;</span><span class="n">te</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">ebs</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">ebs</span><span class="p">;</span>
    <span class="n">rte_meter_get_tb_params</span><span class="p">(</span><span class="n">hz</span><span class="p">,</span> <span class="n">params</span><span class="o">-&gt;</span><span class="n">cir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">cir_period</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">cir_bytes_per_period</span><span class="p">);</span>

    <span class="n">RTE_LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">,</span> <span class="n">METER</span><span class="p">,</span> <span class="s">&quot;Low level srTCM config: </span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="s">&quot;</span><span class="se">\t</span><span class="s">CIR period = %&quot;</span> <span class="n">PRIu64</span> <span class="s">&quot;, CIR bytes per period = %&quot;</span> <span class="n">PRIu64</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">cir_period</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cir_bytes_per_period</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>注意cir_peroid和cir_bytes_per_period的初始化. 首先计算period=CPU频率数/限速速率, 如果这个值够大(dpdk中判断依据为是否大于等于100个时钟周期), 则令牌桶更新单位周期就是period个cycles, 每个周期添加1个字节(令牌); 否则, 每个桶更新周期应更新的令牌数(字节)大于1, 需要特殊处理.</p>
<p>运行时的检测:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">rte_meter_color</span>
<span class="nf">rte_meter_srtcm_color_blind_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_meter_srtcm</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
    <span class="kt">uint64_t</span> <span class="n">time</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="n">pkt_len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">time_diff</span><span class="p">,</span> <span class="n">n_periods</span><span class="p">,</span> <span class="n">tc</span><span class="p">,</span> <span class="n">te</span><span class="p">;</span>

<span class="hll">    <span class="cm">/* Bucket update */</span>
</span><span class="hll">    <span class="n">time_diff</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">;</span>
</span><span class="hll">    <span class="n">n_periods</span> <span class="o">=</span> <span class="n">time_diff</span> <span class="o">/</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cir_period</span><span class="p">;</span>
</span><span class="hll">    <span class="n">m</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">+=</span> <span class="n">n_periods</span> <span class="o">*</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cir_period</span><span class="p">;</span>
</span>
    <span class="n">tc</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">+</span> <span class="n">n_periods</span> <span class="o">*</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cir_bytes_per_period</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cbs</span><span class="p">)</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cbs</span><span class="p">;</span>

    <span class="n">te</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">te</span> <span class="o">+</span> <span class="n">n_periods</span> <span class="o">*</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cir_bytes_per_period</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">te</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">ebs</span><span class="p">)</span>
        <span class="n">te</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">ebs</span><span class="p">;</span>

    <span class="cm">/* Color logic */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&gt;=</span> <span class="n">pkt_len</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">=</span> <span class="n">tc</span> <span class="o">-</span> <span class="n">pkt_len</span><span class="p">;</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">te</span> <span class="o">=</span> <span class="n">te</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">e_RTE_METER_GREEN</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">te</span> <span class="o">&gt;=</span> <span class="n">pkt_len</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">=</span> <span class="n">tc</span><span class="p">;</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">te</span> <span class="o">=</span> <span class="n">te</span> <span class="o">-</span> <span class="n">pkt_len</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">e_RTE_METER_YELLOW</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">m</span><span class="o">-&gt;</span><span class="n">tc</span> <span class="o">=</span> <span class="n">tc</span><span class="p">;</span>
    <span class="n">m</span><span class="o">-&gt;</span><span class="n">te</span> <span class="o">=</span> <span class="n">te</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">e_RTE_METER_RED</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>第9到第11行, 由于dpdk没有定时器触发机制, 所以更新桶并不是每隔一个固定的时间完成的, 而是在每次报文到来时, 用当时的时间减去上一次更新时间, 再除以初始化时设置的周期peroid, 得到间隔周期数, 再乘以每周期应增加的令牌数, 就是当前桶需要增加的令牌数. 注意这里所有的时间值都以CPU cycle数表示.</p>
</div>
</div>
<div class="section" id="id24">
<h2>14.4 多队列与优先级<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h2>
<p>基于dropping的算法，如RED和令牌桶，基于单队列；而round-robin和优先级可用于多队列。</p>
<p>对于多个out队列我们有3个问题需要考虑：</p>
<ol class="arabic simple">
<li>将报文进行分类(比如基于首部某字段)，决定将其放入哪个队列</li>
<li>将放入队列前，依然可以使用RED和令牌桶算法对其进行dropping</li>
<li>如果多个队列都需要发送报文，要决定先服务哪个队列</li>
</ol>
<p>第3个问题是关键，这里举一个简单例子：假设有两个out队列，一个用于付费服务报文，另一个用于其他报文，付费服务报文队列的优先级显然会配置得更高。只要付费服务报文队列中有报文，我们都先发送它，然后才发送其他队列中的报文。这个例子所用的就是最简单的严格优先级(strict priority, SP)算法。</p>
</div>
<div class="section" id="id25">
<h2>14.5 资源预留协议<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<p>资源预留协议用于设置Scheduler的参数。</p>
<ul>
<li><p class="first">QoS概念的引入</p>
<p>QoS就是用于流的性能保证的条款，它需要预留机制和准入控制(限制用于QoS的流的数量)，再加上调度(在选中流上执行性能保证)。QoS是一个模糊的术语，性能保证可以是带宽，时延，或者别的方面。</p>
</li>
<li><p class="first">RSVP</p>
<p>RSVP(Resource Reservation Protocol)允许应用来执行预留手续。</p>
</li>
<li><p class="first">bandwidth broker架构</p>
<p>DiffServ提出了bandwidth broker，它由各域(per domain)执行而不是每个应用。</p>
</li>
</ul>
</div>
<div class="section" id="id26">
<h2>14.6 带宽保证<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
<div class="section" id="id27">
<h3>14.6.1 问题引入<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<p>再介绍具体的带宽保证算法之前，先考虑一个调度问题：</p>
<p>有A和B两个用户，需要将自己的东西(报文)发往一个中转枢纽(调度器)，
中转枢纽将这些东西发往外地(网卡Tx端口)。这个简单的系统有一些问题需要解决。</p>
<p>如果在尽快时A每次都能比B更早地将东西在枢纽处排队，那么B必须等待A的东西全部发完后才能发送自己的东西，如图A。</p>
<img alt="../_images/drr_a.png" src="../_images/drr_a.png" />
<p>为解决此问题，可以给让A和B排两队，枢纽轮流从这两个队列中取走东西(round-robin)，如图B所示。然而，如果A的东西都比B大，显然B吃亏，
因为枢纽服务和转送东西的时间和其大小成正比。</p>
<img alt="../_images/drr_b.png" src="../_images/drr_b.png" />
<p>要解决B吃亏的问题，一种想法是使用相同规格的包裹，A和B必须把东西整理到这些包裹中，再交给枢纽调度，然而这种做法在很多情况下是不现实的。不过，可以以假想的标准规格为单位，计算每一件东西处理所需的时间，然后按时时间大小顺序来决定先处理谁的东西。</p>
<p>图C中，A队中的第一个东西需要的处理时间是3，而B队中第一个东西需要1，为公平起见，先发送B队中的东西。</p>
<img alt="../_images/drr_c.png" src="../_images/drr_c.png" />
<p>发送完成后，来到图D。其中A队情况不变，B队此时第一个东西需要的处理时间是4，此时先发送A队中的东西。</p>
<img alt="../_images/drr_d.png" src="../_images/drr_d.png" />
<p>这样一来，就可以使A、B中的东西都能得到公平的服务。此模拟系统要实现这种算法，至少需要保持每个队列上的时间时间戳，并在发送时从这些队列中选出时间戳值最小的那一个队列，处理其中的第一个东西。如果使用优先队列，此算法的时间复杂度为O(logN)，N是队列的数目。</p>
<p>当有新的队列加入时，原有的调度都需要改变，当然原来每个队列的处理速率也相应改变了。如图E所示。</p>
<img alt="../_images/drr_e.png" src="../_images/drr_e.png" />
</div>
<div class="section" id="deficit-round-robin">
<h3>14.6.1 Deficit Round-Robin<a class="headerlink" href="#deficit-round-robin" title="永久链接至标题">¶</a></h3>
<p>如果只需要实现带宽保证，那么有一种时间复杂度为O(N)的算法：Deficit
Round-Robin。</p>
<p>设每条flow i的quantum为Qi，deficit计数器Di。在每一轮调度时，对flow i，drr算法处理的报文大小不大于(Qi+Di)。如果flow i还有剩余报文，则剩余的Di被储存，用于下一轮，如此循环。</p>
<p>以下用示例说明算法细节。假定有4个flow，每个flow的quantum都为500。在一开始，所有flow的deficit初始化为0。Round-robin指针(RRP)指向第一个活动队列F1。当服务F1时，把quantum加到D1时，此时D1=500，而F1队列首包大小为200，200&lt;500，此报文被发送，并将D1减去200，此时D1=300，而F1首包为750，750&gt;300，此报文不得发送。300储存在D1中，
RRP指向下一个活动队列F2。</p>
<img alt="../_images/drr.png" src="../_images/drr.png" />
<p>接下来，和刚才第一轮一样，DRR将依次分别发送F2、F3、F4的首包，发送完成后D2，D3，D4的值分别为0，400和320。之将RRP重新指向F1，此时D1 = 300 + 500 = 800，F1首包750&lt;800，发送此报文，接着D1=50&gt;20，
发送最后一个长为20的报文，假设此时F1没有更多报文进来，则RRP指向F2，算法继续运行。</p>
<img alt="../_images/drr2.png" src="../_images/drr2.png" />
<p>不过，当RRP转到F2时，F1的deficit计数器D1并不保存剩余的30(800-750-20)，
而是将D1清零，因为此时的F1是空队列。</p>
</div>
<div class="section" id="drr">
<h3>14.6.2 DRR的实现与扩展<a class="headerlink" href="#drr" title="永久链接至标题">¶</a></h3>
<p>DRR的实现要注意以下几点。</p>
<p>(1) 要避免轮询空队列。一种实现方法是维护一个辅助队列ActiveList，
此队列保存了所有非空队列的索引。当服务完某个队列变为空时，就将其索引从ActiveList移除；否则，将其索引放到ActiveList队尾。</p>
<p>(2) DRR保证的带宽与quantum成正比。如有3个flow，quantum值分别为2，
2，3，那么若这3个flow的队列都不为空，则第2条流所占带宽比例为
2/(2+2+3)=2/7；若第3条流队列为空，则第2条流所占带宽比例为2/(2+2)=1/2。在所有情况下，流被保证了 <strong>最小</strong> 带宽。</p>
<p>(3) quantum的选择。quantum的值应该大于流中最大报文的长度，否则出队操作的时间复杂度无法达到O(N)。假如quantum=1，那么发送一个100字节的报文需要访问100次队列，效率非常低。</p>
<p>DRR的扩展主要包括分层DRR以及带有单一优先队列的DRR。</p>
<div class="section" id="id28">
<h4>分层DRR<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h4>
<p>假设有以下场景：出口带宽被两个组织A和B所使用，各自的带宽配额分别是70%和30%；A的Web流量的带宽配额占A总配额的40%，其余60%；B的Web流量和其他流量的带宽配额各为50%。如下图所示：</p>
<img alt="../_images/hdrr.png" src="../_images/hdrr.png" />
<p>可以在此树(称为Class-based Queuing Tree, CBQ tree)的每个节点处应用DRR算法来实现以上需求。</p>
</div>
<div class="section" id="id29">
<h4>带有优先级的DRR<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h4>
<p>Cisco实现了一种DRR(MDRR：Modified DRR)，用于将优先级与DRR结合，
以允许VoIP业务有最小时延。如下图所示。系统最多有8个队列，其中，
队列1用于VoIP业务。系统分2个模式：第一种模式中，队列1被赋予严格优先级(strict priority, SP)，它高于其他所有队列，因此队列1中的所有报文得到处理后才处理其他队列中的报文；在第二种模式中，交替处理队列1和其他队列。</p>
<img alt="../_images/mdrr.png" src="../_images/mdrr.png" />
</div>
</div>
</div>
<div class="section" id="id30">
<h2>14.7 时延保证<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
<p>// TODO</p>
</div>
<div class="section" id="scalable-fair-queuing">
<h2>14.8 Scalable Fair Queuing<a class="headerlink" href="#scalable-fair-queuing" title="永久链接至标题">¶</a></h2>
<p>// TODO</p>
</div>
<div class="section" id="dpdk">
<h2>14.9 dpdk分层调度<a class="headerlink" href="#dpdk" title="永久链接至标题">¶</a></h2>
<p>dpdk QoS框架实现了一个分层调度器(Hierarchical Scheduler)，它一般位于Tx一侧，发送阶段之前，如下图所示。</p>
<img alt="../_images/dpdk_hscheduler.png" src="../_images/dpdk_hscheduler.png" />
<p>dpdk分层调度共分5层：port, subport, pipe, traffic class和queue。
此分层结构形成一个树形结构，叶子是数千个报文队列(一般是64K个)，
实现了流量整形(subport, pipe层)，strict priority(traffic class层)，
和WRR(带权重的round-robin，在每个pipe traffic class内的queue)。</p>
<div class="section" id="id31">
<h3>14.9.1 概述<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h3>
<p>分层调度器动作起来像一个buffer，可以在发送之前暂时存储大量的报文(入队)；之后可以根据报文选择逻辑来发送这些报文到Tx(出队)。</p>
</div>
<div class="section" id="id32">
<h3>14.9.2 调度分层<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<p>dpdk调度的分层如下所示：</p>
<img alt="../_images/dpdk_sched_hierarchy.png" src="../_images/dpdk_sched_hierarchy.png" />
<p>各层功能如下表所示：</p>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="23%" />
<col width="17%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Level</th>
<th class="head">每层数目</th>
<th class="head">功能描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>port</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ol class="first last arabic simple">
<li>Ethernet 1/10/40 GbE出口</li>
<li>多个port的轮询优先级相同</li>
</ol>
</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>subport</td>
<td>可配置(8)</td>
<td><ol class="first last arabic simple">
<li>使用令牌桶进行流量整形</li>
<li>对traffic class(tc)上限进行限制</li>
<li>低优先级的tc能重用高优先级tc暂不使用的subport带宽</li>
</ol>
</td>
</tr>
<tr class="row-even"><td>3</td>
<td>pipe</td>
<td>可配置(4)</td>
<td><ol class="first last arabic simple">
<li>使用令牌桶进行流量整形</li>
</ol>
</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>traffic class</td>
<td>4</td>
<td><ol class="first last arabic simple">
<li>同一pipe的tcs根据strict priority
处理</li>
<li>在pipe层对上tc上限进行限制</li>
<li>低优先级的tc能重用高优先级tc暂不使用的pipe带宽</li>
<li>当subport TC“超额”时(配置期事件)，pipe TC的上限成为一个动态调整值，它被所有subport pipes共享</li>
</ol>
</td>
</tr>
<tr class="row-even"><td>5</td>
<td>queue</td>
<td>4</td>
<td><ol class="first last arabic simple">
<li>同一tc的queues使用WRR进行服务</li>
</ol>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id33">
<h3>14.9.3 实现<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h3>
<div class="section" id="id34">
<h4>内部数据结构<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h4>
<p>每个port的内部数据结构如下图所示(struct rte_sched_port)：</p>
<img alt="../_images/dpdk_sched_datastruct.png" src="../_images/dpdk_sched_datastruct.png" />
<p>其中：</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>subport表项</dt>
<dd>struct rte_sched_subport</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>pipe表项</dt>
<dd>struct rte_sched_pipe，多个pipe可以共享同一个pipe配置，因为配置结构不包括在pipe表项中，而是有一个专门的结构struct
rte_sched_pipe_profile</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>queue表项</dt>
<dd>struct rte_sched_queue，存放队列的读写指针</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>队列存储区</dt>
<dd>struct rte_mbuf*，报文队列，即一个rte_mbuf*数组</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>活动队列bitmap</dt>
<dd>struct rte_bitmap，标识报文队列是否活动</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>grinder</dt>
<dd>struct rte_sched_grinder，存放当前活动pipes的短列表，包含pipe处理期间所需的临时数据</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="id35">
<h4>运行核心部署<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h4>
<p>同一port的入队和出队应在一个线程(lcore)上进行，否则会影响性能。</p>
</div>
<div class="section" id="id36">
<h4>令牌桶逻辑<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h4>
<p>当以下所有条件都满足时，调度器将发送来自(subport S, pipe P,
traffic class TC, queue Q)的报文：</p>
<ul class="simple">
<li>某个port grinder选中了P和S</li>
<li>TC是P中优先级最高的活动流量</li>
<li>P的TC内由WRR选中了Q</li>
<li>S有足够的令牌(token/credit)来发送报文</li>
<li>S对此TC有足够的令牌来发送报文</li>
<li>P有足够的令牌来发送报文</li>
<li>P对此TC有足够的令牌来发送报文</li>
</ul>
<p>若上述所有条件都满足，报文将被发送，且要从S，S-TC, P, P-TC中减去相应数量的令牌。</p>
<p>suport和pipe层通过令牌桶实现了流量整形。其相关参数/数据结构与操作如以下两表所示。</p>
<p>参数：</p>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="40%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">字段</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>tb_time</td>
<td>上次令牌更新的时间</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>tb_period</td>
<td>上次令牌更新到目前所流逝的时间</td>
</tr>
<tr class="row-even"><td>3</td>
<td>tb_credits_per_period</td>
<td>每个tb_period应增加的令牌数</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>tb_size</td>
<td>桶大小，即tb_credits的上限</td>
</tr>
<tr class="row-even"><td>5</td>
<td>tb_credits</td>
<td>当前桶中的令牌数</td>
</tr>
</tbody>
</table>
<p>以上所有参数的单位均是字节，时间与字节数之间的换算见 <a class="reference internal" href="#dpdk-time"><span class="std std-ref">14.2.4.4 时间值的使用</span></a> 。</p>
<p>桶速度(bytes/sec)可以由以下公式算出：</p>
<blockquote>
<div>bucket_rate = (tb_credits_per_period / tb_period) * r</div></blockquote>
<p>r为port线速(单位bytes/sec)。</p>
<p>操作有：</p>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="18%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">令牌桶操作</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>初始化</td>
<td>tb_credits = 0 或 tb_credits = tb_size/2</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>更新</td>
<td><p class="first">每当pipe被选中时，更新pipe及其subport的令牌桶。
更新操作</p>
<div class="last line-block">
<div class="line">n_periods = (time - tb_time) / tb_period;</div>
<div class="line">tb_credits += n_periods * tb_credits_per_period;</div>
<div class="line">tb_credits = min(tb_credits, tb_size);</div>
<div class="line">tb_time += n_periods * tb_period;</div>
</div>
</td>
</tr>
<tr class="row-even"><td>3</td>
<td>消费</td>
<td><p class="first">报文被调度后，减去相应的令牌数。调度操作：</p>
<div class="last line-block">
<div class="line">pkt_credits = pkt_len + frame_overhead;</div>
<div class="line">if (tb_credits &gt;= pkt_credits)</div>
<div class="line-block">
<div class="line">tb_credits -= pkt_credits;</div>
</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>同一pipe中TC的strict priority是由出队状态机(dequeue state machine)实现的，它根据TC编号从小到大的顺序选择队列进行服务。因此，queue 0-3(TC 0)有最高的优先级，其次是queue 4-7(TC 1)，依此类推。</p>
<p>pipe和subport层的TC并没有进行流量整形，因此在此上下文中并没有维护令牌桶。subport和pipe中的TC的上限限制是通过周期性地重填(refill)
subport-TC/pipe-TC令牌计数器来实现的。</p>
<p>subport, pipe上的TC上限限制相关参数：</p>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="37%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">字段</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>tc_time</td>
<td>4个TC下一次更新(上限重填)时间</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>tc_period</td>
<td>两次更新之间的时间间隔，应远大于tb_period的典型值</td>
</tr>
<tr class="row-even"><td>3</td>
<td>tc_credits_per_period</td>
<td>tc_period期间允许TC消费的令牌的上限</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>tc_credits</td>
<td>当前令牌上限的值</td>
</tr>
</tbody>
</table>
<p>相关操作：</p>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="14%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">TC操作</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>初始化</td>
<td><div class="first last line-block">
<div class="line">tc_credits = tc_credits_per_period;</div>
<div class="line">tc_time = tc_period;</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>更新</td>
<td><div class="first last line-block">
<div class="line">if (time &gt;= tc_time) {</div>
<div class="line-block">
<div class="line">tc_credits = tc_credits_per_period;</div>
<div class="line">tc_time = time + tc_period; }</div>
</div>
</div>
</td>
</tr>
<tr class="row-even"><td>3</td>
<td>消费</td>
<td><div class="first last line-block">
<div class="line">pkt_credits = pk_len + frame_overhead;</div>
<div class="line">if (tc_credits &gt;= pkt_credits)</div>
<div class="line-block">
<div class="line">tc_credits -= pkt_credits;</div>
</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>subport TC的超额(oversubscription)是一个配置期事件，指的是在subport的成员pipe层给TC X分配的带宽超过了在subport层给同一TC分配的带宽。</p>
<p>dpdk解决这一问题的方法称为“Cap the high demand pipes”:</p>
<blockquote>
<div>Each subport member pipe receives an equal share of the
bandwidth available at run-time for TC X at the subport level.
Any bandwidth left unused by the low-demand pipes is
redistributed in equal portions to the high-demand pipes.
This way, the high-demand pipes are truncated while the
low-demand pipes are not impacted.</div></blockquote>
<p>此算法计算一个watermark，它的值根据当前subport的pipes的需求周期性地更新。watermark在每次TC上限限制期的开始时在subport计算，且同样的值在当前限制期间用于此subport所有的pipes。</p>
<p>在当前限制期的开始(也就是上一次限制期的结束)时，要基于上一次限制期的开始分配给TC3，但没有被subport的pipes用剩下的带宽来调整watermark。</p>
<p>如果subport TC3有剩余的未用带宽，当前限制期的watermark就会增加以鼓励pipes消费更多带宽。否则，watermark会减小以在pipes之间平等地分配消费带宽。当前pipes TC3的需求增加时，watermark需要减小；而当pipes TC3的需求减小时，watermark需要增大。</p>
<p>当需求较低时，设置足够高的watermark以防止它阻碍subport的pipes消费更多的带宽。</p>
<p>在每个TC上限限制期的开始传播watermark的操作：</p>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="13%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">subport
TC操作</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>初始化</td>
<td><div class="first last line-block">
<div class="line">Subport层: subport_period_id= 0</div>
<div class="line">Pip层: pipe_period_id = 0</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>更新</td>
<td><p class="first">subport层：</p>
<div class="line-block">
<div class="line">if (time&gt;=subport_tc_time) {</div>
<div class="line-block">
<div class="line">subport_wm = water_mark_update();</div>
<div class="line">subport_tc_time = time + subport_tc_period;</div>
<div class="line">subport_period_id++;}</div>
</div>
</div>
<p>pipe层：</p>
<div class="last line-block">
<div class="line">if(pipe_period_id != subport_period_id) {</div>
<div class="line-block">
<div class="line">pipe_ov_credits = subport_wm * pipe_weight;</div>
<div class="line">pipe_period_id = subport_period_id; }</div>
</div>
</div>
</td>
</tr>
<tr class="row-even"><td>3</td>
<td>消费</td>
<td><p class="first">pipe层:</p>
<div class="last line-block">
<div class="line">pkt_credits = pk_len + frame_overhead;</div>
<div class="line">if(pipe_ov_credits &gt;= pkt_credits)</div>
<div class="line-block">
<div class="line">pipe_ov_credits -= pkt_credits;</div>
</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>watermark计算:</p>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="11%" />
<col width="85%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">subport
TC操作</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>初始化</td>
<td><div class="first last line-block">
<div class="line">Subport层: wm = WM_MAX</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>更新</td>
<td><p class="first">subport层(water_mark_update)：</p>
<div class="last line-block">
<div class="line">tc0_cons = subport_tc0_credits_per_period - subport_tc0_credits;</div>
<div class="line">tc1_cons = subport_tc1_credits_per_period - subport_tc1_credits;</div>
<div class="line">tc2_cons = subport_tc2_credits_per_period - subport_tc2_credits;</div>
<div class="line">tc3_cons = subport_tc3_credits_per_period - subport_tc3_credits;</div>
<div class="line">tc3_cons_max = subport_tc3_credits_per_period -</div>
<div class="line-block">
<div class="line">(tc0_cons + tc1_cons + tc2_cons);</div>
</div>
<div class="line">if(tc3_consumption &gt; (tc3_consumption_max - MTU)){</div>
<div class="line-block">
<div class="line">wm -= wm &gt;&gt; 7;</div>
<div class="line">if(wm &lt; WM_MIN) wm = WM_MIN;</div>
</div>
<div class="line">} else {</div>
<div class="line-block">
<div class="line">wm += (wm &gt;&gt; 7) + 1;</div>
<div class="line">if(wm &gt; WM_MAX) wm = WM_MAX; }</div>
</div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="diffserv">
<h2>14.10 DiffServ架构介绍<a class="headerlink" href="#diffserv" title="永久链接至标题">¶</a></h2>
<p>// TODO</p>
</div>
<div class="section" id="dpdk-qos">
<h2>14.11 dpdk QoS框架<a class="headerlink" href="#dpdk-qos" title="永久链接至标题">¶</a></h2>
<p>// TODO</p>
</div>
<div class="section" id="id37">
<h2>附录<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<div class="section" id="ewma">
<span id="ewma-algo"></span><h3>EWMA<a class="headerlink" href="#ewma" title="永久链接至标题">¶</a></h3>
<p>EWMA(Exponential weighted moving average：指数加权移动平均)是一种常用的序列数据处理方式，表述如下：</p>
<p>设t为时刻，A(t)为估计值，V(t)为实测值，w为权重且0&lt;w&lt;1，那么</p>
<blockquote>
<div>A(t) = w * V(t) + (1 - w) * A(t-1)</div></blockquote>
<p>其中，w表征A(t)对于历史测量值的权重系数，其值越接近1，表示对过去测量值的权重越低。从另一个角度看，w决定了EWMA估计器跟踪实际数据突然发生变化的能力，即时效性。显然随着w增大，估计器的时效性就越强，反之就越弱；另一方面，由于w的存在，EWMA还表现出一定的吸收瞬时突发的能力，这种能力称为平稳性。显然随着w减小，估计器的平稳性越强，
反之越弱。</p>
<p>从信息处理角度看，EWMA可看成一个低通滤波器，通过控制w值，剔除短期波动，保留长期发展趋势，提供了信号的平滑形式。</p>
<p>下面通过一个C++程序演示了EWMA的作用。程序中，假定有10个时刻，每个时刻测定的值放在数组q中；avg为估计值。程序根据用户输入的权重w，
计算时刻0-9时的EWMA估计值avg。代码如下</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">double</span> <span class="nf">ewma</span><span class="p">(</span><span class="kt">double</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">double</span> <span class="n">q</span><span class="p">,</span> <span class="kt">double</span> <span class="n">avg</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">w</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">q</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="p">};</span>
    <span class="kt">double</span> <span class="n">avg</span><span class="p">,</span> <span class="n">total</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;usage: %s &lt;weight&gt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">t</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">q</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="n">total</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;avg: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">avg</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">t</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">ewma</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">avg</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">avg</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">ewma</span><span class="p">(</span><span class="kt">double</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">double</span> <span class="n">q</span><span class="p">,</span> <span class="kt">double</span> <span class="n">avg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">w</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">avg</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当指定不同w值时，EWMA估计值avg的变化如下表所示</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">w</th>
<th class="head">0</th>
<th class="head">1</th>
<th class="head">2</th>
<th class="head">3</th>
<th class="head">4</th>
<th class="head">5</th>
<th class="head">6</th>
<th class="head">7</th>
<th class="head">8</th>
<th class="head">9</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>3.30</td>
<td>3.30</td>
<td>3.30</td>
<td>3.30</td>
<td>3.30</td>
<td>3.30</td>
<td>3.30</td>
<td>3.30</td>
<td>3.30</td>
<td>3.30</td>
</tr>
<tr class="row-odd"><td>0.005</td>
<td>3.29</td>
<td>3.28</td>
<td>3.28</td>
<td>3.28</td>
<td>3.31</td>
<td>3.31</td>
<td>3.30</td>
<td>3.30</td>
<td>3.31</td>
<td>3.30</td>
</tr>
<tr class="row-even"><td>0.05</td>
<td>3.19</td>
<td>3.13</td>
<td>3.12</td>
<td>3.16</td>
<td>3.41</td>
<td>3.39</td>
<td>3.32</td>
<td>3.30</td>
<td>3.39</td>
<td>3.32</td>
</tr>
<tr class="row-odd"><td>0.5</td>
<td>2.15</td>
<td>2.08</td>
<td>2.54</td>
<td>3.27</td>
<td>5.63</td>
<td>4.32</td>
<td>3.16</td>
<td>3.08</td>
<td>4.04</td>
<td>3.02</td>
</tr>
<tr class="row-even"><td>0.8</td>
<td>1.46</td>
<td>1.89</td>
<td>2.78</td>
<td>3.76</td>
<td>7.15</td>
<td>3.83</td>
<td>2.37</td>
<td>2.87</td>
<td>4.57</td>
<td>2.51</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>8</td>
<td>3</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>用图表表示如下</p>
<img alt="../_images/ewma.png" src="../_images/ewma.png" />
<p>从以上数据可以看出，越小的w值会使估计值越平稳，而越大的w值则会使估计值越能反映实际值的变化。</p>
</div>
</div>
<div class="section" id="id38">
<h2>参考<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h2>
<table class="docutils citation" frame="void" id="net-algo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[net_algo]</td><td>&#8220;Network Algorithmics&#8221;, George Varghese, 2005</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id39" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[ewma]</a></td><td><a class="reference external" href="http://blog.csdn.net/x_i_y_u_e/article/details/44194761">EWMA指数加权移动平均模型</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id41" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[red]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id10">2</a>, <a class="fn-backref" href="#id11">3</a>)</em> &#8220;Random Early Detection Gateways for Congestion Avoidance&#8221;,Sally Floyd &amp; Van Jacobson, IEEE/ACM, 1993</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rfc2697" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[rfc2697]</td><td><em>(<a class="fn-backref" href="#id14">1</a>, <a class="fn-backref" href="#id18">2</a>)</em> RFC 2697, A Single Rate Three Color Marker</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rfc2698" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[rfc2698]</td><td><em>(<a class="fn-backref" href="#id15">1</a>, <a class="fn-backref" href="#id21">2</a>)</em> RFC 2698, A Two Rate Three Color Marker</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rfc2475" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[rfc2475]</td><td>RFC 2475, An Architecture for Differentiated Services</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id42" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[dpdk]</td><td><a class="reference external" href="http://dpdk.org">intel DPDK</a></td></tr>
</tbody>
</table>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../wireshark/index.html" class="btn btn-neutral float-right" title="wireshark" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="proto_process.html" class="btn btn-neutral" title="9 Protocol Processing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Zhao Ziqing.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0.0',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>