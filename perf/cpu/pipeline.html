

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>理解流水线与超标量执行 &mdash; zzq&#39;s blog</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/hacks.css" type="text/css" />
  

  
        <link rel="index" title="索引"
              href="../../genindex.html"/>
        <link rel="search" title="搜索" href="../../search.html"/>
    <link rel="top" title="zzq&#39;s blog" href="../../index.html"/>
        <link rel="up" title="CPU知识" href="index.html"/>
        <link rel="next" title="理解带宽与时延" href="bandwidth.html"/>
        <link rel="prev" title="理解微处理器" href="microprocessor.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> 赵子清技术文章
          

          
          </a>

          
            
            
              <div class="version">
                2018.12
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../lang/index.html">程序设计语言</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../lang/cpp/index.html">C++ 11</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../lang/cpp/preface.html">前言</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/cpp/preface.html#c">C++的变化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/cpp/preface.html#id2">对C++程序员的建议</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/cpp/preface.html#id3">对C程序员的建议</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/cpp/preface.html#c-11">C++11主要特性</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/cpp/preface.html#id4">参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/cpp/basic.html">基本功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/cpp/oop.html">面向对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/cpp/stl.html">标准库</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/cpp/boost.html">boost库</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../lang/go/index.html">Golang</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../lang/go/setup.html">环境配置</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/go/setup.html#go-get">使用代理以解决go get超时问题</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/go/setup.html#id2">日常项目开发环境配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/go/setup.html#ide">IDE配置</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/go/json.html">JSON解析</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/go/json.html#id1">简单解析</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/go/json.html#id2">不确定JSON的解析</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/go/json.html#id3">复杂内容的解析</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/go/withc.html">C语言适配</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/go/withc.html#id1">调用C编写的动态库</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/go/books.html">学习资料</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../lang/lua/lua_basic.html">lua基础</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../lang/lua/lua_basic.html#id1">预备知识</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id2">获得lua</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id3">lua命令行</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id4">保留关键字</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id5">注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#chunk">Chunk</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/lua/lua_basic.html#id6">数据类型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#string">string</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#userdata">userdata</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#thread">thread</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/lua/lua_basic.html#id7">表达式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id8">算术运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id9">关系运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id10">逻辑运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id11">连接运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id12">运算符优先级</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/lua/lua_basic.html#id13">语句</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id14">赋值</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id15">局部变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id16">条件语句</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/lua/lua_basic.html#id17">循环语句</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/lua/lua_basic.html#id18">函数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../lang/shell/index.html">Linux shell编程</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../lang/asm/index.html">汇编语言</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../lang/asm/arch.html">计算机体系结构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/arch.html#cpu">CPU</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/arch.html#id5">内存</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/arch.html#id6">中断</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/asm/asm_intro.html">汇编语言简介</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/asm_intro.html#id2">汇编代码的两种记法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/asm_intro.html#centosnasm">CentOS运行nasm</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/asm_intro.html#id3">操作数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/asm_intro.html#id4">基本指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/asm_intro.html#id5">指示符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/asm_intro.html#id6">输入输出</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/asm_intro.html#id7">代码模板</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/asm_intro.html#id8">第一个程序</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/asm/basic.html">语言基础</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/basic.html#id2">数据移动</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/basic.html#id3">算术运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/basic.html#id4">位操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/basic.html#id7">控制流</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/basic.html#id8">栈操作与函数调用</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/asm/simd.html">intel SIMD指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/asm/debug.html">调试</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/debug.html#linux-gdb">Linux + gdb</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/asm/withc.html">与C语言互操作</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/withc.html#id1">调用约定</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/withc.html#id2">C调用汇编代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/withc.html#id3">汇编调用C代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../lang/asm/withc.html#id4">结构体</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../lang/byteorder.html">字节序与比特序</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../lang/byteorder.html#id2">字节序</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/byteorder.html#id3">比特序</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lang/byteorder.html#id4">编写可移植代码</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../algo/index.html">数据结构与算法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../algo/list.html">链表,栈与队列</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../algo/list.html#id2">单向链表</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../algo/list.html#id3">双向链表</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../algo/list.html#id4">侵入式数据结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../algo/list.html#id5">栈</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../algo/list.html#id6">队列</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../algo/list.html#id7">基本实现</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../algo/list.html#id8">下标的处理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../algo/list.html#id9">无锁队列</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../algo/tree.html">树</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../algo/tree.html#id2">二叉查找树</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../algo/tree.html#avl">AVL树</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../algo/tree.html#id3">红黑树</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../algo/hash.html">哈希表</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algo/graph.html">图</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algo/visit.html">遍历</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algo/order.html">排序</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algo/find.html">查找</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algo/ac.html">AC算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algo/regex.html">正则表达式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../algo/regex.html#id2">1. 概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../algo/regex.html#parse">2. 解析(parse)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../algo/regex.html#id3">2.1 词法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../algo/regex.html#id4">2.2 语法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../algo/regex.html#id5">2.3 抽象语法树</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../algo/regex.html#compile">3. 编译(compile)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../algo/regex.html#nfa">3.1 构造NFA</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../algo/regex.html#nfadfa">3.2 NFA转DFA</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../algo/regex.html#id7">3.4 消除死状态</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../algo/regex.html#dfa">3.5 DFA最小化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../algo/regex.html#id8">3.6 DFA序列化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../algo/regex.html#match">4. 匹配(match)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../algo/regex.html#id9">5. 优化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../algo/regex.html#id10">5.1 内存</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../algo/regex.html#id11">5.2 性能</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../algo/regex.html#id12">参考</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../net/index.html">网络开发</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../net/tcpip/index.html">TCP/IP详解</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../net/netalgo/index.html">网络算法学</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../net/netalgo/proto_process.html">9 Protocol Processing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/proto_process.html#id1">9.1 缓存管理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/proto_process.html#crcchecksum">9.2 CRC和Checksum</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/proto_process.html#id4">9.3 通用协议处理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/proto_process.html#id5">9.4 重组</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/proto_process.html#id7">9.5 结论</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../net/netalgo/sched_packet.html">14 Scheduling Packets</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#id1">14.1 概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#id2">14.2 拥塞控制</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#id13">14.3 带宽与突发限制</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#id24">14.4 多队列与优先级</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#id25">14.5 资源预留协议</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#id26">14.6 带宽保证</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#id30">14.7 时延保证</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#scalable-fair-queuing">14.8 Scalable Fair Queuing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#dpdk">14.9 dpdk分层调度</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#diffserv">14.10 DiffServ架构介绍</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#dpdk-qos">14.11 dpdk QoS框架</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#id37">附录</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../net/netalgo/sched_packet.html#id38">参考</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../opensource/index.html">开源项目研究</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../opensource/dpdk/index.html">DPDK</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/intro.html">1. 引言</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/intro.html#id2">1.1. 由来</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/intro.html#dpdk">1.2. DPDK最佳实践</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/intro.html#id3">1.3. dpdk框架</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/intro.html#id4">1.4. dpdk的应用</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/hf_mem_cache.html">2. 深入浅出dpdk: cache与内存</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_mem_cache.html#cache">2.1. 内存Cache简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_mem_cache.html#id3">2.2. Cache地址映射与变换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_mem_cache.html#id4">2.3. Cache的写策略</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_mem_cache.html#id5">2.4. Cache预取</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_mem_cache.html#id8">2.5. Cache一致性</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_mem_cache.html#tlb">2.6. TLB和大页</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_mem_cache.html#ddio">2.7. DDIO</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_mem_cache.html#numa">2.8. NUMA系统</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_mem_cache.html#id9">2.9. 参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/hf_parallel.html">3. 深入浅出dpdk: 并行计算</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/hf_sync.html">4. 深入浅出dpdk: 同步充斥机制</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_sync.html#id1">4.1. 原子锁</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_sync.html#id2">4.2. 读写锁</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_sync.html#id3">4.3. 自旋锁</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_sync.html#id4">4.4. 无锁机制</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/hf_pkt_forward.html">5. 深入浅出dpdk: 报文转发</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_pkt_forward.html#id1">5.1. 网络处理模块分解</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_pkt_forward.html#id2">5.2. 转发模型</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_pkt_forward.html#id3">5.3. 转发算法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/hf_pkt_io.html">6. 深入浅出dpdk: PCIe与包处理IO</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/hf_nic_optimize.html">7. 深入浅出dpdk: 网卡性能优化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_nic_optimize.html#id1">7.1. dpdk轮询模式</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_nic_optimize.html#burst">7.2. burst收发包的思想与实现</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_nic_optimize.html#id2">7.3. 硬件平台的影响</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_nic_optimize.html#id3">7.4. 软件平台的影响</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_nic_optimize.html#id4">7.5. 队列长度及各种阈值的设置</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/hf_classify.html">8. 深入浅出dpdk: 流分类与多队列</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_classify.html#id1">8.1. 多队列技术</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/hf_classify.html#id2">8.2. 流分类</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/hf_hw_accel.html">9. 深入浅出dpdk: 硬件加速与功能卸载</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/eal.html">10. 源码分析: EAL</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/eal.html#linuxeal">10.1. Linux环境的EAL</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/eal.html#id1">10.2. 内存机制与初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/eal.html#cpu">10.3. CPU信息取得与核绑定</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/eal.html#lcore">10.4. 线程/lcore的初始化与启动</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/eal.html#id2">10.5. 多进程应用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/eal.html#id3">10.6. 其他注意事项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/eal.html#id4">10.7. 参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/ring.html">11. 源码分析: Ring</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/ring.html#id1">11.1. 概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/ring.html#id2">11.2. 应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/ring.html#id3">11.3. 无锁队列操作图解</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/ring.html#id4">11.4. 数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/ring.html#id5">11.5. 多生产者入队</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/ring.html#id6">11.6. 多消费者出队</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/ring.html#id7">11.7. 索引计算</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/ring.html#id8">11.8. 参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/mem.html">12. 源码分析: Memory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mem.html#id1">12.1. 内存的初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mem.html#id4">12.2. 参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/memseg.html">13. 源码分析: Memseg</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/memseg.html#id1">13.1. 概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/memseg.html#id2">13.2. 数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/memseg.html#id3">13.3. 初始化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/memzone.html">14. 源码分析: Memzone</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/memzone.html#id1">14.1. 概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/memzone.html#memzone-init">14.2. 初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/memzone.html#id3">14.3. 内存分配</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/memzone.html#id4">14.4. 内存释放</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/memzone.html#id5">14.5. 参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/malloc.html">15. 源码分析: Malloc</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/malloc.html#id1">15.1. 概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/malloc.html#id2">15.2. 数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/malloc.html#malloc-heap">15.3. malloc heap初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/malloc.html#malloc-heap-alloc">15.4. 内存分配</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/malloc.html#id4">15.5. 内存释放</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/malloc.html#id5">15.6. 参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/mempool.html">16. 源码分析: Mempool</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mempool.html#id1">16.1. 概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mempool.html#id2">16.2. 特性</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mempool.html#id4">16.3. 数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mempool.html#id5">16.4. 创建</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mempool.html#id6">16.5. 取出对象</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mempool.html#id7">16.6. 还回对象</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mempool.html#id8">16.7. 参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/mbuf.html">17. 源码分析: Mbuf</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mbuf.html#id1">17.1. 概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mbuf.html#id2">17.2. 原理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mbuf.html#id3">17.3. 数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mbuf.html#id4">17.4. 分配与回收</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mbuf.html#id8">17.5. 元信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mbuf.html#directindirect-mbuf">17.6. Direct和Indirect mbuf</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/mbuf.html#id9">17.7. 参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/dpdk/build_sys.html">18. 编译系统</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/build_sys.html#id2">18.1. 概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/build_sys.html#id3">18.2. 源码组织</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/build_sys.html#id5">18.3. 编译系统</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/build_sys.html#dpdk-makefile">18.4. dpdk Makefile介绍</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/build_sys.html#root-makefile-help">18.5. 根Makefile介绍</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/build_sys.html#abi">18.6. ABI管理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/build_sys.html#v16-07-2">18.7. 实例：将v16.07.2编译为单个动态库</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/dpdk/build_sys.html#id22">18.8. 参考</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../opensource/tengine/index.html">Tengine</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/tengine/intro.html">介绍</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/intro.html#tengine">Tengine的由来</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/intro.html#id2">Tengine的改进</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/tengine/arch.html">架构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/arch.html#id2">高性能服务器设计</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/arch.html#id3">进程模型</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/arch.html#id5">事件处理模型</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/arch.html#id7">模块化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/arch.html#id9">请求处理机制</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/arch.html#id10">参考资料</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/tengine/key_points.html">基本概念</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/key_points.html#connection">连接/connection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/key_points.html#request">请求/request</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/key_points.html#keepalive">keepalive</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/key_points.html#pipeline">pipeline</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/key_points.html#lingering-close">lingering_close</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/key_points.html#id6">参考资料</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/tengine/infrastructure.html">基础设施</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/infrastructure.html#id2">日志</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/infrastructure.html#id3">内存管理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/infrastructure.html#cycle">cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/infrastructure.html#id7">字符串操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/infrastructure.html#id12">容器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/infrastructure.html#id18">时间</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/infrastructure.html#id19">网络</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/infrastructure.html#id21">事件</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/infrastructure.html#id22">进程</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/infrastructure.html#id23">线程</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/infrastructure.html#id24">模块</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/infrastructure.html#id25">错误处理</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/tengine/http.html">HTTP</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/tengine/http.html#id1">HTTP请求处理</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../opensource/wireshark/index.html">wireshark</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../opensource/hyperscan/index.html">hyperscan</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/hyperscan/hs_intro.html">hyperscan介绍</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/hyperscan/hs_intro.html#how-we-match-regular-expressions">首席工程师: How we match regular expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/hyperscan/hs_intro.html#id1">源码结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/hyperscan/hs_intro.html#id2">参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/hyperscan/hs_pre.html">hyperscan预备知识</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/hyperscan/hs_pre.html#c-11">C++ 11</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/hyperscan/hs_pre.html#id5">设计模式</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/hyperscan/hs_pre.html#id6">数据结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/hyperscan/hs_pre.html#boost-library">Boost Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/hyperscan/hs_pre.html#ragel">Ragel</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../opensource/hyperscan/hs_debug.html">hyperscan调试环境与技巧</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/hyperscan/hs_debug.html#id1">编译</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/hyperscan/hs_debug.html#dump">生成dump信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/hyperscan/hs_debug.html#id4">加速编译过程</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../opensource/hyperscan/hs_debug.html#id5">生成源码文档</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../ai/index.html">人工智能</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ai/books.html">学习资料</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ai/books.html#pattern-recognition-and-machine-learning">Pattern Recognition and Machine Learning</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ai/books.html#convex-optimization">Convex Optimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ai/books.html#deep-learning-fundamentals-an-introduction-for-beginners">Deep Learning Fundamentals: An Introduction for Beginners</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ai/books.html#optimization-in-operations-research">Optimization in Operations Research</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ai/books.html#artificial-intelligence-a-modern-approach">Artificial Intelligence: A Modern Approach</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ai/books.html#deep-learning-in-natural-language-processing">Deep Learning in Natural Language Processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ai/books.html#id2">机器学习</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ai/books.html#deep-learning">Deep Learning</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">性能优化</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">CPU知识</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="microprocessor.html">理解微处理器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="microprocessor.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="microprocessor.html#code-and-data-a-closer-look">Code and Data: a closer look</a></li>
<li class="toctree-l4"><a class="reference internal" href="microprocessor.html#meet-the-file-clerk">meet the &#8220;file clerk&#8221;</a></li>
<li class="toctree-l4"><a class="reference internal" href="microprocessor.html#refining-the-model">Refining the model</a></li>
<li class="toctree-l4"><a class="reference internal" href="microprocessor.html#ram-when-the-registers-alone-don-t-cut-it">RAM: when the registers alone don&#8217;t cut it</a></li>
<li class="toctree-l4"><a class="reference internal" href="microprocessor.html#a-closer-look-at-the-code-stream-the-program">A closer look at the code stream: the program</a></li>
<li class="toctree-l4"><a class="reference internal" href="microprocessor.html#excursus-op-codes-and-machine-language">Excursus: Op codes and machine language</a></li>
<li class="toctree-l4"><a class="reference internal" href="microprocessor.html#the-programming-model-and-the-isa">The programming model and the ISA</a></li>
<li class="toctree-l4"><a class="reference internal" href="microprocessor.html#branch-instructions">Branch instructions</a></li>
<li class="toctree-l4"><a class="reference internal" href="microprocessor.html#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">理解流水线与超标量执行</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pipelining-explained">Pipelining Explained</a></li>
<li class="toctree-l4"><a class="reference internal" href="#superscalar-execution">Superscalar execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#combining-pipelined-and-superscalar-execution">Combining pipelined and superscalar execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conclusions">Conclusions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="bandwidth.html">理解带宽与时延</a></li>
<li class="toctree-l3"><a class="reference internal" href="intel_p4.html">NetBurst: The Microarchitecture of the Pentium 4 Processor</a><ul>
<li class="toctree-l4"><a class="reference internal" href="intel_p4.html#id1">引言</a></li>
<li class="toctree-l4"><a class="reference internal" href="intel_p4.html#netburst">NetBurst微架构概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="intel_p4.html#id4">时钟频率</a></li>
<li class="toctree-l4"><a class="reference internal" href="intel_p4.html#id6">NetBurst微架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="intel_p4.html#id10">性能</a></li>
<li class="toctree-l4"><a class="reference internal" href="intel_p4.html#id11">结论</a></li>
<li class="toctree-l4"><a class="reference internal" href="intel_p4.html#id12">作者</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="glossary.html">CPU相关术语及缩略语</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../simd_demo.html">SIMD指令编程demo</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../simd_demo.html#id1">正常代码</a></li>
<li class="toctree-l3"><a class="reference internal" href="../simd_demo.html#id2">一次循环计算4次</a></li>
<li class="toctree-l3"><a class="reference internal" href="../simd_demo.html#sse">使用SSE指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../simd_demo.html#avx">使用AVX指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../simd_demo.html#id3">性能对比</a></li>
<li class="toctree-l3"><a class="reference internal" href="../simd_demo.html#id4">更多参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../intel_dev_manual/index.html">Intel开发手册</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intel_dev_manual/vol1/index.html">卷1: 基础架构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../intel_dev_manual/vol1/1.html">1 About This Manual</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_dev_manual/vol1/2.html">2 INTEL 64 AND IA-32 ARCHITECTURES</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_dev_manual/vol1/3.html">3 BASIC EXECUTION ENVIRONMENT</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../intel_opt_manual/index.html">Intel优化手册</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intel_opt_manual/2.html">2 INTEL 64 AND IA-32 PROCESSOR ARCHITECTURES</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/2.html#skylake-server">Skylake Server</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/2.html#skylake">Skylake</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/2.html#haswell">Haswell</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/2.html#haswell-e">Haswell-E</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/2.html#broadwell">Broadwell</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/2.html#sandy-bridge">Sandy Bridge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/2.html#ivy-bridge">Ivy Bridge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/2.html#core-enhanced-core">Core &amp; Enhanced Core</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/2.html#nehalem">Nehalem</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/2.html#id1">超线程技术</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/2.html#id2">64位架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/2.html#simd">SIMD技术</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../intel_opt_manual/3.html">3 一般性优化原则</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/3.html#id2">3.1 性能工具</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/3.html#id4">3.2 处理器全景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/3.html#id7">3.3 编程规则, 建议及调整提示</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/3.html#id8">3.4 优化前端</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/3.html#optimizing-the-execution-core">3.5 OPTIMIZING THE EXECUTION CORE</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/3.html#optimizing-memory-accesses">3.6 OPTIMIZING MEMORY ACCESSES</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/3.html#prefetching">3.7 PREFETCHING</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/3.html#floating-point-considerations">3.8 FLOATING-POINT CONSIDERATIONS</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/3.html#maximizing-pcie-performance">3.9 MAXIMIZING PCIE PERFORMANCE</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../intel_opt_manual/7.html">7 优化cache使用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/7.html#general-prefetch-coding-guidelines">7.1 GENERAL PREFETCH CODING GUIDELINES</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/7.html#prefetch-and-cacheability-instructions">7.2 PREFETCH AND CACHEABILITY INSTRUCTIONS</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/7.html#prefetch">7.3 PREFETCH</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/7.html#cacheability-control">7.4 CACHEABILITY CONTROL</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/7.html#memory-optimization-using-prefetch">7.5 MEMORY OPTIMIZATION USING PREFETCH</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_opt_manual/7.html#memory-optimization-using-non-temporal-stores">7.6 MEMORY OPTIMIZATION USING NON-TEMPORAL STORES</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../intel_vtune/index.html">Intel VTune Amplifier</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intel_vtune/intro.html">介绍</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/intro.html#id2">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/intro.html#id3">调优方法论</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/intro.html#id4">安装</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/intro.html#id5">一般使用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/intro.html#id10">参考资料</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../intel_vtune/tutorial_hotspots.html">教程: 优化热点</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_hotspots.html#id2">编译示例程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_hotspots.html#vtune">创建vtune工程并运行分析</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_hotspots.html#id3">分析代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_hotspots.html#id4">优化代码</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../intel_vtune/tutorial_hardware.html">教程: 优化硬件利用率</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_hardware.html#id2">编译示例程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_hardware.html#vtune">创建vtune工程并运行分析</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_hardware.html#id3">分析代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_hardware.html#id4">优化代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_hardware.html#id5">进一步分析和优化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../intel_vtune/tutorial_false_sharing.html">教程: 优化伪共享</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_false_sharing.html#id2">编译示例程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_false_sharing.html#vtune">创建vtune工程并运行分析</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_false_sharing.html#id3">分析代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tutorial_false_sharing.html#id4">优化代码</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../intel_vtune/tunning_guide_e5v3.html">调优指南: Xeon E5 v3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tunning_guide_e5v3.html#intel-xeon-e5-v3-family">1 Intel Xeon E5 v3 Family</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tunning_guide_e5v3.html#id1">2 性能测量的复杂性</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tunning_guide_e5v3.html#id2">3 发现性能问题</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tunning_guide_e5v3.html#front-end-bound">4 调优Front-End Bound</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tunning_guide_e5v3.html#back-end-bound">5 调优Back-End Bound</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tunning_guide_e5v3.html#bad-speculation">6 调优Bad Speculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tunning_guide_e5v3.html#retiring">7 调优Retiring</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intel_vtune/tunning_guide_e5v3.html#id12">8 附加主题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">工具与杂项</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tools/vim/index.html">Vim</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/vim/intro.html">简介与基本配置</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/vim/intro.html#vim">为什么要使用vim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/vim/intro.html#id2">本系列文章的指导思想和一些约定</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/vim/intro.html#id3">学习之前的基本配置和几个需要了解的基本操作</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/git/index.html">Git</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/git/basic_command.html">Git常用命令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/git/basic_command.html#id2">一、新建代码库</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/git/basic_command.html#id3">二、配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/git/basic_command.html#id4">三、增加/删除文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/git/basic_command.html#id5">四、代码提交</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/git/basic_command.html#id6">五、分支</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/git/basic_command.html#id7">六、标签</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/git/basic_command.html#id8">七、查看信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/git/basic_command.html#id9">八、远程同步</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/git/basic_command.html#id10">九、撤销</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/git/basic_command.html#id11">十、其他</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/git/tricks.html">小技巧</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/git/tricks.html#shellsshgithub">shell通过SSH连接github</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/git/tricks.html#id2">在命令提示符中显示当前分支</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/rest/index.html">用reST编写文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/rest/intro.html">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/rest/setup.html">安装与基本使用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/setup.html#id2">安装软件包</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/setup.html#id3">项目建立</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/setup.html#conf-py">conf.py配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/setup.html#index">index页配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/setup.html#id6">参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/rest/grammar.html">reST语法介绍</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id1">章节标题</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id2">段落</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id3">行内标记</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id4">列表</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id5">代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id6">超链接</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id7">图片</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id8">表格</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id9">引用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id10">脚注</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id11">提醒</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id12">替换</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/grammar.html#id13">参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/rest/style.html">修改样式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/style.html#step1">Step1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/style.html#step2">Step2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/style.html#step3">Step3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/rest/topdf.html">生成PDF</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/topdf.html#xetex">方法一：使用xeTex(推荐)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/topdf.html#cjkutf8">方法二: 使用CJKutf8包 (默认)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/topdf.html#id1">终极解决办法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/rest/doxygen.html">生成API文档</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/doxygen.html#step1">Step1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/doxygen.html#step2">Step2</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/doxygen.html#step3">Step3</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/doxygen.html#step4">Step4</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/rest/with_vscode.html">在Visual Studio Code中使用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/with_vscode.html#id1">安装步骤</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/with_vscode.html#id2">配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/with_vscode.html#id3">使用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/with_vscode.html#id4">问题记录</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/rest/add_comment.html">给github博客添加评论功能</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/add_comment.html#oauth-application">1. 注册OAuth Application</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/add_comment.html#id1">2. 编辑博客页面, 引入gitment</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/add_comment.html#id2">3. 初始化评论</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/rest/add_comment.html#id3">参考链接</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/latex/index.html">LaTeX</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/latex/setup.html">安装与配置</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/latex/setup.html#id2">1. 安装</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/latex/setup.html#id3">2. 卸载</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/latex/quick_start.html">快速入门示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/latex/text.html">文本与段落</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/latex/code.html">程序代码</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/latex/figure_table.html">图像与表格</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/latex/debug.html">错误调试</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/vpn.html">VPS+Shadowsocks科学上网</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/vpn.html#vps">购买VPS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/vpn.html#shadowsocks">配置shadowsocks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/vpn.html#id2">服务器端</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/vpn.html#id3">客户端</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/vpn.html#id4">其他技巧</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/vpn.html#id5">对不同网站使用不同的连接方式: 直接/代理</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/vpn.html#window">Window下令无法设置代理的应用程序使用代理</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/vpn.html#id6">参考链接</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/patch.html">补丁工具patch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/patch.html#id1">1 为单个文件生成补丁</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/patch.html#id2">2 为多个文件生成补丁</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/patch.html#id3">3 打补丁</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/patch.html#id4">4 示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/libpcap.html">libpcap使用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/libpcap.html#id1">创建句柄</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/libpcap.html#pcap-open-offline">pcap_open_offline</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/libpcap.html#pcap-dump-open">pcap_dump_open</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/libpcap.html#id2">关闭句柄</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/libpcap.html#pcap-close">pcap_close</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/libpcap.html#pcap-dump-close">pcap_dump_close</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/libpcap.html#packet">读取packet</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/libpcap.html#pcap-open-pcap-dispatch">pcap_open/pcap_dispatch</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/libpcap.html#id3">设置选项</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/libpcap.html#pcap-set-promisc">pcap_set_promisc</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/libpcap.html#id4">其他</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/libpcap.html#pcap-breakloop">pcap_breakloop</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/libpcap.html#pcap-file">pcap_file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/libpcap.html#pcap-dump-file">pcap_dump_file</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/libpcap.html#id5">参考</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/cunit.html">CUnit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/cunit.html#cunit-2-1-3">编译安装CUnit-2.1-3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/vmware.html">VMWare使用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/vmware.html#ip">配置静态IP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/vmware.html#id1">解决启动黑屏问题</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/centos.html">CentOS应用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/centos.html#centos7-3minimalc-c">CentOS7.3Minimal从零配置C/C++开发环境</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/centos.html#failed-to-start-lsb-bring-up-down-networking">网络配置失败,显示Failed to start LSB: Bring up/down networking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/centos.html#centoswindows">共享CentOS虚拟机上的文件给Windows本机访问</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/centos.html#pip">安装pip</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/ubuntu.html">Ubuntu应用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/ubuntu.html#id1">14.04更换阿里云源</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/ubuntu.html#youcompleteme">安装YouCompleteMe插件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/ubuntu.html#cpu">隔离某些cpu核心</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/ubuntu.html#vmware-workstationubuntu-server">VMware Workstation中的Ubuntu Server虚拟机重启后共享文件夹消失</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/ubuntu.html#cannot-set-lc-ctype-to-default-locale-no-such-file-or-directory">Cannot set LC_CTYPE to default locale: No such file or directory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/ubuntu.html#man">man文档不全</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/ubuntu.html#id2">修改系统对消息队列的默认限制</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/xiaomi_router.html">小米路由器开发</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/xiaomi_router.html#rom">用ROM刷机</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/xiaomi_router.html#ssh">开启SSH</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/xiaomi_router.html#id2">交叉编译环境搭建</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/xiaomi_router.html#id3">交叉编译库或工具</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/xiaomi_router.html#libpcap">编译libpcap</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/xiaomi_router.html#helloworld">编译helloworld</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/xiaomi_router.html#gdb">编译gdb</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/xiaomi_router.html#id4">其他</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/xiaomi_router.html#id5">在小米路由器上部署静态网页</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/qemu.html">QEMU模拟器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/qemu.html#id2">安装软件包</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/qemu.html#id3">用户模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/qemu.html#id4">系统模式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tools/qemu.html#id5">一般使用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/qemu.html#id6">配置网络</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tools/qemu.html#gdb">远程gdb调试</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hobby/index.html">兴趣爱好</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../hobby/record_bilibili.html">录制B站直播</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../hobby/record_bilibili.html#ffmpeg">安装ffmpeg</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hobby/record_bilibili.html#id1">解析直播地址</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hobby/record_bilibili.html#id2">录制</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../hobby/video_trick.html">视频制作相关小技巧</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../hobby/video_trick.html#b">如何下载B站视频，或者用微博发的视频？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hobby/video_trick.html#mac">Mac系统下应该用什么软件做视频编辑？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hobby/video_trick.html#q-mac-gif">Q: Mac系统如何做动图（gif）？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hobby/video_trick.html#gif-fcpx">我有一些动图（gif），怎么将它们导入到fcpx？直接导入发现它们不动了啊！</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hobby/video_trick.html#id2">Mac系统如何录制系统自己发出的声音，比如我正在听一首很好听的歌但是不方便下载它？</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../aboutme.html">关于我</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">赵子清技术文章</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">性能优化</a> &raquo;</li>
        
          <li><a href="index.html">CPU知识</a> &raquo;</li>
        
      <li>理解流水线与超标量执行</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>理解流水线与超标量执行<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p><em>本文更新于 2018.10.22</em></p>
<p>参考: <a class="reference external" href="http://archive.arstechnica.com/paedia/c/cpu/part-2/cpu2-1.html">http://archive.arstechnica.com/paedia/c/cpu/part-2/cpu2-1.html</a></p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="永久链接至标题">¶</a></h2>
<p>In my previous article, <a class="reference external" href="http://archive.arstechnica.com/paedia/c/cpu/part-1/cpu1-1.html">Understanding the Microprocessor</a> , I gave a
high-level overview of what a microprocessor is and how it functions. I talked
about the kinds of tasks it performs and the different steps that it goes through
to carry out those tasks. The vision of the microprocessor which emerged from
that article was fairly simple and straightforward. It was also fairly limited
and primitive. Modern microprocessors are more complex&#8211;they do more things in
more complicated ways than the first article really implies. The present article
will discuss two major innovations in processor design that have brought about
huge leaps in processor performance: pipelining and superscalar execution. If
you&#8217;re going to understand modern processors, you have to master these two
concepts. Most of the newer tricks and techniques that I&#8217;ve covered in previous
Ars articles on new CPUs are aimed at improving the performance of one or both
of these two fundamental design approaches.</p>
</div>
<div class="section" id="pipelining-explained">
<h2>Pipelining Explained<a class="headerlink" href="#pipelining-explained" title="永久链接至标题">¶</a></h2>
<p>You&#8217;ll often hear the term &#8220;pipelining&#8221; in discussions of CPU technology, but the
term itself is rarely defined. Pipelining is a fairly simple concept, though,
and the following section will make use of an analogy in order to explain how
it works.</p>
<p>(Note: The following discussion of pipelining is adapted from <a class="reference external" href="http://www.arstechnica.com/cpu/3q99/k7_theory/k7-one-1.html">one of my articles</a> on the K7,
aka Athlon. I&#8217;ve reworked the analogy a bit, but the diagrams are the same.)</p>
<p>Let&#8217;s say that we at Ars decided to quit doing tech journalism and go into the
increasingly lucrative SUV manufacturing business. After some intense research,
we determine that there are five stages in the SUV building process, as follows:</p>
<ul class="simple">
<li><strong>Stage 1</strong>: build the chassis.</li>
<li><strong>Stage 2</strong>: drop the engine in the chassis.</li>
<li><strong>Stage 3</strong>: put doors, a hood, and coverings on the chassis.</li>
<li><strong>Stage 4</strong>: attach the wheels.</li>
<li><strong>Stage 5</strong>: paint the SUV.</li>
</ul>
<p>When we first hit on the idea of using an assembly line, we decided that it would
be best to hire and train five crews of specialists, one for each stage of the
SUV building process. There&#8217;s one group to build the chassis, one to build the
engine and drop it in, another for the wheels, etc. Each stage of the SUV building
process takes a crew exactly one hour to complete.</p>
<p>Now, since we Ars guys are computer types and not industrial engineers, we&#8217;re not
too bright when it comes to making efficient use of factory resources. Also,
because Ars was started back in the dot-com boom days, we&#8217;re still kind of stuck
in that mindset so we run a pretty chill shop with lots of free snacks, foosball
tables, arcade games and other such employee perks. So our big plan is to have the
factory run as follows: we line up all five crews in a row, and we have the first
crew start an SUV at Stage 1. After Stage 1 is complete, the SUV moves down the
line to the next stage and the next crew drops the engine in. While the Stage 2
Crew is installing the engine in the chassis that the Stage 1 Crew just built,
the Stage 1 Crew (along with all of the rest of the crews) is free to go play
foosball, watch the big-screen plasma TV in the break room, surf the &#8216;net, etc.
Once the Stage 2 Crew is done, the SUV moves down to Stage 3 and the Stage 3 Crew
takes over while the Stage 2 Crew hits the break room to party with everyone else.</p>
<p>The SUV moves on down the line through all five stages this way, with only one
crew working on one stage at any given time while the rest of the crews are idle.
Once the completed SUV finishes Stage 5, the crew at Stage 1 then starts on
another SUV. At this rate, it takes exactly five hours to finish a single SUV,
and our factory puts out one SUV every five hours.</p>
<p>The following picture shows our assembly line with a SUV in Stage 2. It&#8217;s having
it&#8217;s engine installed while the other crews are idle.</p>
<img alt="../../_images/pipeline_1.gif" src="../../_images/pipeline_1.gif" />
<p>Now, you may be thinking, Why not just have one full-time crew to do all the work?
The nominal, stated reason (i.e. the reason Caesar gave when he was pitching this
assembly line idea to the rest of the Ars team) is that each stage of construction
requires a specific skill set. If we hire five, highly skilled crews to do the
job then it&#8217;ll wind up taking us less time overall to build a SUV than if we
hired only one crew that&#8217;s not very good (or very fast) at completing any of the
five stages.</p>
<p>Of course, the real reason for having five crews (at least as far as I&#8217;m concerned)
is that Caesar, in classic Roman nepotistic fashion, believes in hiring his relatives
and in paying them outrageously to spend most of their time playing foosball.
And Caesar has a pretty large family. But for the purposes of the present
discussion we&#8217;ll pretend I didn&#8217;t say this.</p>
<p>(Fast-forward one year.) Our SUV, the Ars Extinction LE (if you put &#8220;LE&#8221; on the
end of the name you can charge more), is selling like... well, it&#8217;s selling like
an SUV, which means it&#8217;s doing pretty well. In fact, it was awarded Car and
Driver&#8217;s prestigious &#8220;Ridiculously Aggressive-looking Design of the Year&#8221; award,
as well as the Global Climate Coalition&#8217;s &#8220;Excellence in Environmental Innovation&#8221;
award for its stunningly low 0.5 mpg rating. (In case it&#8217;s not obvious, GCC is an
&#8220;environmental&#8221; front group for the oil industry.) So demand for our SUV has
speeded up, but unfortunately Caesar&#8217;s relatives have not.</p>
<p>Caesar&#8217;s first plan for increasing plant output was to hire members of his wife&#8217;s
family to form a second assembly line, also capable of producing one car every
five hours, for a grand total of two cars every five hours from our factory floor.
At this point, though, the rest of the Ars crew had become wise to his game, and
we put our collective foot down: Big C.&#8217;s people will just have to find a way
to play less foosball and build more cars.</p>
<p>Lucky for us, Caesar&#8217;s Republican instincts have led him to firmly suppress any
attempts at labor organizing (even though the &#8220;labor&#8221; is essentially his
family&#8211;yes, he is that vicious), which means that our demands for increased
productivity won&#8217;t trigger a strike. So Caesar and the rest of the board hire
a high-priced and high-powered team of consultants to figure out a way to increase
productivity. One year and thousands of billable hours later, they hit upon a
solution: with proper scheduling of the crews, we can build one SUV each hour,
and thus drastically improve the efficiency of our assembly line. The revised
workflow looks as follows: Crew 1 builds a chassis and finishes it, and then
sends it on to Crew 2. While Crew 2 is dropping the engine in, Crew 1 starts on
another chassis... and so on. (Of course, this is how most of us nowadays in the
post-Ford era expect a good, efficient assembly line to work.)</p>
<p>If we can keep the assembly line full, and keep all five crews working at once,
then we can spit out a SUV every hour: a five-fold improvement in production.
Here&#8217;s a picture of our fully pipelined assembly line. Notice that all the clocks
read the same time. That&#8217;s because all the stages are full at once, and all the
crews are busy at once. That, in a nutshell, is pipelining.</p>
<img alt="../../_images/pipeline_2.gif" src="../../_images/pipeline_2.gif" />
<p>So, back to the world of computers. You might recall from <a class="reference external" href="http://archive.arstechnica.com/paedia/c/cpu/part-1/cpu1-1.html">the previous article</a>
that a computer basically just repeats four basic steps over and over again in
order to execute a program:</p>
<ol class="arabic simple">
<li><strong>Fetch</strong> the next instruction from the address stored in the program counter.</li>
<li>Store that instruction in the instruction register and <strong>decode</strong> it, and
increment the address in the program counter.</li>
<li><strong>Execute</strong> the instruction in the instruction register.</li>
<li>Repeat steps 1-3.</li>
</ol>
<p>You should also recall step 3, the execute stage, itself consists of three steps.
In the case of the ADD A, B example that we used last time, the steps are:</p>
<ol class="arabic simple">
<li><strong>Read</strong> the contents of registers A and B.</li>
<li><strong>Add</strong> the contents of A and B.</li>
<li><strong>Write</strong> the result back to register A.</li>
</ol>
<p>At this point, I&#8217;d like to modify the first list above by removing step 4 as an
explicit step and replacing it with step 3 from the second list. Here&#8217;s what I&#8217;m
talking about:</p>
<ol class="arabic simple">
<li><strong>Fetch</strong> the next instruction from the address stored in the program counter.</li>
<li>Store that instruction in the instruction register and <strong>decode</strong> it, and
increment the address in the program counter.</li>
<li><strong>Execute</strong> the instruction currently in the instruction register.</li>
<li><strong>Write</strong> the results of that instruction from the ALU back into the destination register.</li>
</ol>
<p>In a modern processor, the four steps above get repeated over and over again until
the program is done executing. These are, in fact, the four stages in a classic
RISC pipeline. Here are the four stages in their abbreviated form, the form in
which you&#8217;ll most often see them:</p>
<ol class="arabic simple">
<li>Fetch</li>
<li>Decode</li>
<li>Execute</li>
<li>Write</li>
</ol>
<p>To return to our assembly line analogy, each of the above stages could be said
to represent one stage in the life-cycle of an instruction. An instruction starts
out in the fetch stage, moves to the decode stage, then to the execute stage,
and finally to the write stage. Early processors were like our first, inefficient
assembly line: there was only one instruction in the pipeline at a time, and as
the instruction moved to each successive stage all of the other stages would lie
idle. The result of this was that if each stage took 10 ms to complete, then the
processor could finish only one instruction every 40 ms.</p>
<p>Once pipelined execution is introduced, the four stages act like four stages in
a regular automotive assembly line. When the pipeline is at full capacity, each
stage is busy working on an instruction and the whole pipeline is able to spit
out one instruction right after the other. If each stage takes 10 ms to complete,
then a full pipeline can process one instruction every 10ms.</p>
<div class="section" id="basic-instruction-flow">
<h3>Basic instruction flow<a class="headerlink" href="#basic-instruction-flow" title="永久链接至标题">¶</a></h3>
<p>One useful division that computer architects use when talking about CPUs is that
of &#8220;front end&#8221; vs. &#8220;back end&#8221; or &#8220;execution engine.&#8221; As already know, when
instructions are fetched from the cache or main memory, they must be fetched and
decoded for execution. This fetching and decoding takes place in the processor&#8217;s
<strong>front end</strong> . The front end roughly corresponds to the control and I/O units
in the previous article&#8217;s diagram of the programming model.</p>
<img alt="../../_images/pipeline_3.png" src="../../_images/pipeline_3.png" />
<p>The following diagram, along with some of the current discussion, was adapted
from my first P4 vs. G4e article. It shows three different execution units:
the load-store unit (LSU), the integer or arithmetic-logic unit (ALU), and the
floating-point unit (FPU). Since we haven&#8217;t yet talked about putting more than
one execution unit in the processor, just ignore the LSU and FPU for now.
They&#8217;ll show up again in the next section.</p>
<img alt="../../_images/pipeline_4.gif" src="../../_images/pipeline_4.gif" />
<p>Instructions make their way from the cache to the front end and down through the
<strong>execution engine</strong> (or <strong>back end</strong> ), which is where the actual work of number
crunching gets done. The back end corresponds roughly to the ALU and registers
in the programming model.</p>
<p>Here&#8217;s a diagram of instruction flow that shows all four pipeline stages. Note
that in this particular diagram the write stage happens to be labeled &#8220;retire.&#8221;</p>
<img alt="../../_images/pipeline_5.jpg" src="../../_images/pipeline_5.jpg" />
<p>This basic pipeline represents the path that instructions take through the processor.</p>
</div>
<div class="section" id="pipelining-and-clock-speed">
<h3>Pipelining and clock speed<a class="headerlink" href="#pipelining-and-clock-speed" title="永久链接至标题">¶</a></h3>
<p>All of a CPU&#8217;s parts march in lock-step to the beat of a single clock. Everything
is timed by that clock pulse, so that the faster the clock the faster the CPU runs.
(For more on CPU clocking, see <a class="reference external" href="http://www.arstechnica.com/cpu/1q99/clocklock-1.html">this article</a> .) The amount of time
that it takes to complete one pipeline stage is exactly one CPU clock cycle.
Thus a faster clock means that each of the individual pipeline stages take less
time. In terms of our assembly line analogy, we could imagine that Caesar has a
strictly enforced rule that each crew must take at most one hour and not a minute
more to complete their work and send the SUV along to the next stage. If Caesar
were really evil and he wanted to squeeze more production out of the entire assembly
line, he could tinker with the large clock on the factory floor and speed it up
by a few minutes an hour. Assuming the crew members don&#8217;t have watches and are all
timing their work by that one, sped up clock, then if Caesar shortens each &#8220;hour&#8221;
by 10 mins the assembly line will move faster and will produce one SUV every 50
minutes.</p>
<p>If you think about it, saying that each pipeline stage can take at most one clock
cycle to complete is equivalent to saying that to entire pipeline can only be as
fast as its slowest stage. In other words, the amount of time it takes for the
slowest stage in the pipeline to complete will be the length of the CPU&#8217;s clock
cycle and thus of each pipeline stage. Again, to return to the SUV analogy, let&#8217;s
say that Caesar had such great results with shortening the factory&#8217;s &#8220;hours&#8221; by
10 minutes that he wants to shave another 10 minutes off, reducing each &#8220;hour&#8221; to
40 minutes total. There&#8217;s one problem, though. Stage 2, in which the engine is
installed, is by far the most difficult and time-consuming of the five stages.
The fastest that the Stage 2 Crew can complete an engine installation is 45 minutes.
Well, since all of the other crews are running off of the same clock as the Stage
2 Crew, this means that the most Caesar can shorten the factory &#8220;hour&#8221; by is 15
minutes, to 45 minutes.</p>
<p>Because of this feature of pipelining, one of the most difficult and important
challenges which the CPU designer faces is that of balancing the pipeline so
that no one stage has to do more work to do than any other. The designer must
distribute the work of processing an instruction evenly to each stage, so that
no one stage takes up too much time and thus slows down the entire pipeline.</p>
</div>
<div class="section" id="some-concluding-remarks-on-pipelining">
<h3>Some concluding remarks on pipelining<a class="headerlink" href="#some-concluding-remarks-on-pipelining" title="永久链接至标题">¶</a></h3>
<p>Pipelining, in essence, allows the CPU to process multiple instructions at the
same time. A four-stage pipeline like the one described above gives the processor
a &#8220;window&#8221; of four instructions. This window slides along the code stream,
moving forward by one instruction each clock cycle, and allows the processor
to &#8220;look at&#8221; and work on all four of the instructions in its window. So unlike
the simple processors in the previous article, pipelined processors &#8220;hold&#8221; and
operate on more than one instruction. For a variety of reasons, there are some
portions of the code stream for which this kind of four-instruction window just
doesn&#8217;t work. These rough spots in the codes stream complicate things for the CPU
architect. In the next article, I&#8217;ll cover these complications and how the architect
can overcome them.</p>
<p>As you probably already know, all pipelines are not four stages. Rather, the four
stages represent the minimum breakdown of labor found in a modern, pipelined
processor. For many processors, these four stages are further subdivided into
even smaller stages. Because of the aforementioned relationship of clockspeed to
the number of pipeline stages, more and shorter pipeline stages = a faster
clock speed. (Note that the number of pipeline stages is referred to as the
<strong>pipeline depth</strong> . So our four-stage pipeline has a pipeline depth of four.)</p>
<p>To see what I&#8217;m talking about, check out the following breakdown of pipeline
stages from <a class="reference external" href="http://arstechnica.com/cpu/01q2/p4andg4e/p4andg4e-3.html">this page</a>
of my P4 vs. G4e article.</p>
<img alt="../../_images/pipeline_6.png" src="../../_images/pipeline_6.png" />
<p>As you can see from the above table, the more advanced G4e breaks the G4&#8217;s
four-stage down into two separate, shorter stages. Likewise the decode and write
stages are also broken down into smaller stages. (We&#8217;ll talk about what the terms
&#8220;issue,&#8221; &#8220;complete,&#8221; and &#8220;dispatch&#8221; mean in the next article.)</p>
<p>The execute stage appears to be the only stage that isn&#8217;t subdivided, but looks
can be deceiving. In fact, the execute stage is one of the most subdivided stages
in many processors&#8217; pipelines. It&#8217;s usually listed in most basic pipeline diagrams
as a single stage for convenience&#8217;s sake, because it&#8217;s generally understood that
it consists of multiple, single-cycle stages.</p>
<p>That the execute stage (or maybe we should use the broader term, <strong>execute phase</strong> )
actually consists of multiple pipeline stages shouldn&#8217;t be a shock to you, though.
In both this article and the previous one we&#8217;ve seen that there&#8217;s actually quite
a bit going on in this phase. And the more complicated the instruction that&#8217;s
being executed, the more steps there are in its execution. Integer instructions,
like our ADD A, B, are usually very simple and can be completed in a minimum number
of steps. More complicated instructions, like a floating-point division, involve
multiple stages of addition and bit-shifting to get a result. (Remember, the only
math that computers really do is addition and bit shifting.) So the number of
execution stages in the pipeline of a floating-point unit will be greater than
the number of execution stages in the pipeline of a regular ALU.</p>
</div>
</div>
<div class="section" id="superscalar-execution">
<h2>Superscalar execution<a class="headerlink" href="#superscalar-execution" title="永久链接至标题">¶</a></h2>
<p><a class="reference external" href="http://archive.arstechnica.com/paedia/c/cpu/part-1/cpu1-1.html">The previous article</a>
covered the processor as it is visible to the programmer. The register files,
the processor status word, the ALU, and other parts of the programming model are
all there to provide a means for the programmer to manipulate the processor and
make it do useful work. In other words, the programming model is essentially a
user interface for the CPU.</p>
<p>Much like the graphical user interfaces on modern computer systems, there&#8217;s a
lot more going on &#8220;under the hood&#8221; than the simplicity of the interface would
imply. In my article on <a class="reference external" href="http://arstechnica.com/paedia/h/hyperthreading/hyperthreading-1.html">multithreading, superthreading and hyper-threading</a> ,
I talked about the various ways in which the OS and processor collaborate to
fool the user into thinking that he or she is executing multiple programs at once.
There&#8217;s a similar sort of trickery that goes on beneath the programming model in
a modern microprocessor, but it&#8217;s intended to fool the programmer into thinking
that there&#8217;s only one thing going on at a time, when really there are multiple
things happening simultaneously. Let me explain.</p>
<p>Back in the days when you could fit only a few transistors on a single die, many
of the parts of the programming model actually fit on separate chips attached to
a single circuit board. For instance, one chip would contain the ALU, another the
control unit, another the registers, etc. Such computers were obviously quite slow,
and the fact that they were made of multiple chips made them expensive. Each chip
had its own manufacturing and packaging costs, so the fewer chips you put on a
board the cheaper the overall system was. Each chip had its own manufacturing
and packaging costs, and then there was the cost and complexity of putting them
all together on a single circuit board. (Note that this is still true, today.
The cost of producing systems and components can be drastically reduced by packing
the functionality of multiple chips into a single chip.)</p>
<p>With the advent of the Intel 4004 in 1971, all of that changed. The 4004 was the
world&#8217;s first microprocessor on a chip. Designed to be the brains of a calculator
manufactured by a now defunct company named Busicom, the 4004 had sixteen 4-bit
registers, an ALU, decoding and control logic all packed onto a single, 2,300
transistor chip. The 4004 was quite a feat for its day, and it paved the way for
the PC revolution. However, it wasn&#8217;t until Intel released the 8080 four years
later that the world saw the first true general purpose CPU. (For a good history
of the development of the microprocessor, see
<a class="reference external" href="http://news.com.com/2009-1001-275806.html">http://news.com.com/2009-1001-275806.html</a></p>
<p>During the decades following the 4004, transistor densities increased at a
stunning pace. As CPU designers had more and more transistors to work with when
designing new chips, they began to think up novel ways for using those transistors
to increase computing performance on application code. One of the first things
that occurred to designers was that they could put more than one ALU a chip,
and have both ALUs working in parallel to process code faster. Since these designs
could do more than one scalar (or integer, for our purposes) operation at once,
they were called <strong>superscalar computers</strong> . The RS6000 from IBM was released in
1990 and was the world&#8217;s first superscalar CPU. Intel followed in 1993 with the
Pentium, which with its two ALUs brought the x86 world into the superscalar era.</p>
<p>Superscalar processing adds a bit of complexity to the processor&#8217;s control unit
because it&#8217;s now tasked not only with fetching and decoding instructions, but
with reordering the linear instruction stream so that some of its individual
instructions could execute in parallel. Furthermore, once executed the instructions
must be put back in the order in which they were originally fetched, so that both
the programmer and the rest of the system have no idea that the instructions weren&#8217;t
executed in their proper sequence.</p>
<p>This last point is important, since even though there are multiple ALUs in the
hardware <em>the programming model does not change</em> . The programmer still writes to
the same interface, even though that interface now represents a fundamentally
different type of machine than the processor actually is (i.e. the interface
represents a sequential execution machine and the processor is actually a parallel
execution machine). So even though the superscalar CPU executes instructions in
parallel, the illusion of sequential execution absolutely must be maintained for
the sake of the programmer.</p>
<p>The important thing to remember is that main memory still sees one code stream,
one data stream and one results stream. However, the code and data streams are
carved up inside the computer and pushed through the two ALUs in parallel.</p>
<div class="section" id="one-challenge-to-superscalar-design-structural-hazards">
<h3>One challenge to superscalar design: structural hazards<a class="headerlink" href="#one-challenge-to-superscalar-design-structural-hazards" title="永久链接至标题">¶</a></h3>
<p>Designing a superscalar CPU presents the processor architect with a whole new set
of challenges. I&#8217;m only going to talk about one of these challenges in the current
article, because I&#8217;ll address the others in the next article. In order to motivate
our discussion of the this challenge, let&#8217;s look at a short code example that shows
superscalar execution in action. Assuming the programming model that I presented
last time, consider the following snippet of code:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>.
.
15 ADD A, B
16 ADD C, D
.
.
</pre></div>
</div>
<p>On a non-superscalar CPU like the one from the first article, the ALU would first
add the contents of registers A and B, placing the results in A. When that addition
was complete, it would then add the contents of C and D, placing the results in D.
However, suppose we add a second ALU to our simple processor. Both of the
instructions would then be executed simultaneously, with each ALU executing one
of the two instructions.</p>
<p>Now, this example presumes that both ALUs share the same group of eight registers.
In order for our register file to accommodate multiple ALU&#8217;s accessing it at once,
however, it needs to be modified. Otherwise, executing the above two instructions
in parallel would trigger what&#8217;s called a <strong>structural hazard</strong> , where the processor
doesn&#8217;t have enough resources to execute both instructions at once.</p>
</div>
<div class="section" id="excursus-the-register-file">
<h3>Excursus: the register file(寄存器堆)<a class="headerlink" href="#excursus-the-register-file" title="永久链接至标题">¶</a></h3>
<p>In a superscalar design, it would require an enormous number of wires to connect
each register directly to each ALU. This problem gets worse as the number of
registers and ALUs increases. Hence, in superscalar design with a large number
of registers, a CPU&#8217;s registers are grouped together into a special unit called
a <strong>register file</strong> . This unit is a memory array, much like the kinds of memory
arrays I&#8217;ve detailed in the Ars RAM Guide, and it&#8217;s accessed through an interface
that allows the ALU to read from or write to specific registers. This interface
consists of a data bus and two types of ports: the read ports and the write ports.
In order to read a value from a single register in the register file, the ALU
accesses the register file&#8217;s <strong>read port</strong> and requests that the data from a specific
register be placed on the special internal data bus that the register file shares
with the ALU. Likewise, writing to the register file is done through the file&#8217;s
<strong>write port</strong> .</p>
<p>A single read port allows the ALU to access a single register at a time, so in
order for an ALU to read from two registers simultaneously (like in the case of
our two-operand ADD instruction) the register file must have two read ports.
Likewise, a write port allows the ALU to write to only one register at a time,
so an ALU needs a single write port in order to be able to write the results of
an operation back to a register. Therefore the register file needs two read ports
and one write port for each ALU. So for our two-ALU superscalar design, the register
file needs a total of four read ports and two write ports.</p>
<p>It so happens that the amount of die space that the register file takes up
increases approximately with the square of the number of ports, so there is a
practical limit on the number of ports that a given register file can support.
This is one of the reasons why modern CPUs use separate register files to store
integer, floating-point, and vector numbers. Since each type of math (integer
floating-point, vector) uses a different type of <strong>execution unit</strong> , attaching multiple
integer, floating-point, and vector execution units to a single register file
would result in quite a large file. (An execution unit is a generic term for a
unit that executes instructions. The ALU is a type of execution unit that executes
integer and logical instructions only. The FPU (floating-point unit) executes
only floating-point instructions, and the VPU (vector processing unit) executes
only vector instructions. We&#8217;ll cover the different types of execution units in
more detail, below.)</p>
<p>There&#8217;s also another reason for using multiple register files to accommodate
different types of execution units. As the size of the register file increases,
so does the amount of time it takes to access it. You might recall from the first
article&#8217;s discussion of registers that we assume that register reads and writes
happen instantaneously. If a register file gets too large and the access latency
gets too high, this can slow down register accesses to the point where such
access are no longer for all intents and purposes instantaneous, but instead
take up a noticeable amount of time. So instead of using one, massive register
file for each type of numerical data, computer architects use two or three register
files, connected to a few different types of execution units.</p>
<p>Incidentally, if you&#8217;ll recall the previous article&#8217;s discussion of op codes, our
simple computer used a series of binary numbers to designate which of the eight
registers an instruction was accessing. Well, in the case of a read these numbers
are fed into the register file&#8217;s interface in order to specify which of the
registers should place its data on the data bus. Taking our 2-bit register
designations as an example, a port on our 8-register file would have two lines
that would be held at either high or low voltages (depending on whether the bit
placed on each line was a 1 or a 0), and these lines would tell the file which of
its registers should have its data placed on the data bus.</p>
</div>
<div class="section" id="superscalar-conclusions">
<h3>Superscalar conclusions<a class="headerlink" href="#superscalar-conclusions" title="永久链接至标题">¶</a></h3>
<p>Running out of resources like registers isn&#8217;t the only thing that can stop a
superscalar processor from issuing multiple instructions in parallel. Sometimes,
the instructions themselves are arranged in ways that lock them into a specific,
sequential execution order. In such cases, the processor has to jump through some
hoops in order to extract <strong>instruction-level parallelism (ILP)</strong> from the code
stream. I&#8217;ll cover these challenges in the next article, so stay tuned.</p>
</div>
</div>
<div class="section" id="combining-pipelined-and-superscalar-execution">
<h2>Combining pipelined and superscalar execution<a class="headerlink" href="#combining-pipelined-and-superscalar-execution" title="永久链接至标题">¶</a></h2>
<p>Let&#8217;s take a look at another version of one of the diagrams above. This version
shows all four &#8220;stages&#8221; of the basic pipeline, but with the twist that the number
of actual pipeline stages in the execute &#8220;stage&#8221; (or execute phase) varies
depending on the particular execution unit.</p>
<img alt="../../_images/pipeline_7.jpg" src="../../_images/pipeline_7.jpg" />
<p>The green ALU above has only one stage in its <strong>execution pipeline</strong> . As I
mentioned previously, arithmetic-logic operations are the simplest and shortest
type of operation, so they need the smallest number of execution stages. The
purple floating-point unit, on the other hand, has 4 execution stages in its
execution pipeline. Again, this is because floating-point operations are complex
and take a long time to complete. In order to keep from having to slow down all
of the processor&#8217;s stages in order to accommodate a single-stage FPU, most CPU
designers divide FPU&#8217;s execution pipeline into multiple, single-cycle stages.</p>
<p>Let&#8217;s return to our assembly line analogy one last time in order to tie things
together. Now that the Ars Extinction LE has done so well, we&#8217;d like to diversify
our product line by adding both a souped up sport model with a beefier engine,
the Ars Extinction Turbo, and an economy model with a smaller engine, the Ars
Extinction (with no suffix). The only way in which any of our three SUVs differ
is in the type of engine they have. This being the case, we can the most
economical use of our existing capacity by making changes only to Stage 2 of our
assembly line. We decide to hire two additional Stage 2 Crews for a total of
three Stage 2 Crews&#8211;one to install each type of engine. We set up the two new
crews with work areas on the floor, and change our workflow as follows.</p>
<img alt="../../_images/pipeline_8.png" src="../../_images/pipeline_8.png" />
<p>After the chassis leaves Stage 1, it goes to one of the three versions of Stage 2.
Each of the versions of Stage 2 send their completed work onto the same Stage 3,
and the assembly line moves on normally from there.</p>
<p>Notice that Stage 2 Turbo is actually composed of two, one-hour stages: Stage 2a
Turbo, in which the engine is placed in the chassis, and Stage 2b Turbo, in which
the chassis is reinforced so that it can handled the increased horsepower of the
Turbo engine. So for an Ars Extinction Turbo, the complete assembly line consists
of six actual stages.</p>
<p>To illustrate both pipelining and parallel execution in action, consider the
following sequence of three SUV orders sent out to the empty factory floor,
right when the shop opens up:</p>
<ol class="arabic simple">
<li>Ars Extinction Turbo</li>
<li>Ars Extinction Turbo</li>
<li>Ars Extinction LE</li>
</ol>
<p>Now let&#8217;s follow these three cars through the assembly line during the first four
hours of the day.</p>
<p><strong>Hour 1:</strong> The line is empty when the first Turbo enters it and the Stage 1
Crew kicks into action.</p>
<img alt="../../_images/pipeline_9.png" src="../../_images/pipeline_9.png" />
<p><strong>Hour 2:</strong> The first Turbo moves on to Stage 2a, while the second Turbo enters
the line.</p>
<img alt="../../_images/pipeline_10.png" src="../../_images/pipeline_10.png" />
<p><strong>Hour 3:</strong> Both of the Turbos are in the line being worked on when the LE enters
the line.</p>
<img alt="../../_images/pipeline_11.png" src="../../_images/pipeline_11.png" />
<p><strong>Hour 4:</strong> Now all three cars are in the assembly line at different stages.
Notice that there are actually three cars in various versions and stages of
&#8220;Stage 2,&#8221; all at the same time.</p>
<img alt="../../_images/pipeline_12.png" src="../../_images/pipeline_12.png" />
<p>In case it isn&#8217;t obvious, Stage 2 in our analogy is the execute phase of the
pipeline. In a superscalar, pipelined processor multiple types of instructions
(e.g. floating-point, integer, etc.) can be in multiple stages of execution
simultaneously.</p>
<p>If you replace the stages in the charts above with the four standard CPU pipeline
stages, also replacing economy with memory access instructions, LE with ALU
instructions, and Turbo with floating-point instructions, it should be obvious
how a three-way superscalar, pipelined CPU with a two-stage floating-point pipeline
would execute the following code:</p>
<ol class="arabic simple">
<li>FADD A, B</li>
<li>FADD C, D</li>
<li>ADD E, F</li>
</ol>
<p>(Note that FADD is the mnemonic for the floating-point add instruction.)</p>
<p>Try working back through the assembly line example with the recommended replacements
in order to get a feel for how a real processor would handle the code above.</p>
</div>
<div class="section" id="conclusions">
<h2>Conclusions<a class="headerlink" href="#conclusions" title="永久链接至标题">¶</a></h2>
<p>Both pipelined and superscalar execution are ways of enlarging the processor&#8217;s
&#8220;window&#8221; on the code stream. Because the code stream is always sequential,
enlarging the window means making it longer so that it encompasses more
sequentially ordered instructions. As the processor enlarges the window via
these two techniques, it gains the ability to hold and to work on more instructions
simultaneously. Now, think about that for a minute. Both superscalar and pipelined
execution are in some sense both forms of parallel execution. They both involve
the simultaneous processing of multiple instructions.</p>
<p>As we widen our window on the code stream, though, the very sequential nature of
that stream makes it harder and harder for the processor to do useful work on all
of those instructions at once. This is because the code stream was &#8220;meant&#8221; to be
serial, and the results of many instructions often depend on the results of prior
instructions. In other words, the instructions that make up the code stream are
interdependent in complex ways that make it hard to rearrange them and get the
same results. The next article will shed some light on the nature of that
interdependence, as well as on the ways that CPU architects try to overcome the
limitations it imposes.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bandwidth.html" class="btn btn-neutral float-right" title="理解带宽与时延" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="microprocessor.html" class="btn btn-neutral" title="理解微处理器" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, 赵子清.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'2018.12.01',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>